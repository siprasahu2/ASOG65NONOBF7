#Wed Jan 25 01:17:08 IST 2023
[condition][]the table {table_name} does not exists in the data base=((new ASOGTABLE()).checkNonExistenceOfTable({table_name}))
[condition][]it is not true that_checkCcnaIcscCombinationInSECONDARYSOURCETARGETINFO{xmlInstance} {ccna} {icsc}=(!((new SuplementOrderCheck()).checkCcnaIcscCombinationInSECONDARYSOURCETARGETINFO({xmlInstance},{ccna},{icsc})))
[condition][]the_section {section} with field {field} is not unique accross all occurences then errorcode {errorcode}=(virtualIsUnique({section},(xcb.xpath({field})).stringValue(),{errorcode}))
[condition][]it is not true that_containsSpaceInSpecRange{var0} {var1} {var2}=(!((new Contains()).containsSpaceInSpecRange({var0},{var1},{var2})))
[condition][]the field{field} with segment{segment} equals{value}=((new Position()).compareSpecifiedSegmentWithValue((xcb.xpath({field})).stringValue(),{segment},{value}))
[condition][]the {field} has_an abbreviation name=((new ThoroughFareHelper()).fetchAbbreviationName((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the interval between {field_date1} and {field_date2} is greater than {days}=(!((new DateCheck()).intervalBetweenTwoDateIsGreaterThanDays((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue(),{days})))
[condition][]it is not true that_virtualOccurenceofEIandUACTinUNIMAPPING{section} {errorcode}=(!(virtualOccurenceofEIandUACTinUNIMAPPING({section},{errorcode})))
[condition][]any occurance of the {field_with_xpath} is not equal to {values} values=((new Occurence()).anyOccurenceNotEqualToValues((xcb.xpath({field_with_xpath})).stringValue(),{values}))
[condition][]it is not true that_numericCheckFormat{var0} {var1} {var2}=(!((new SpecialFormat()).NumericCheckFormat({var0},{var1},{var2})))
[condition][]it is not true that_the {pos} position_of {field} is in range {start_value} and {end_value}=(!((new Populated()).isPostionOfFieldPopulatedInRange({pos},(xcb.xpath({field})).stringValue(),{start_value},{end_value})))
[condition][]the minimum length of {field} is {value}=((new LengthCheck()).checkMinimumLength((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_set the request type of to {var0}=(!((new ReqTypeAct()).setRequestType({var0})))
[condition][]it is not true that_the {field} has_date format as check3 {YYMMDD}=(!((new DateFormatCheck()).dateCheck3((xcb.xpath({field})).stringValue(),{YYMMDD})))
[condition][]it is not true that_the position {pos} of {field} is not_equal_to_values {comma_seperated_values}=(!((new Position()).positionOftagValueNotEqualToValues({pos},(xcb.xpath({field})).stringValue(),{comma_seperated_values})))
[condition][]from the {pos1} to {pos2} has {format} for the {field}=((new DateFormatCheck()).time_format_chk({pos1},{pos2},{format},(xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the no of occurances of {field_xpath} pair have different {field_xpath} values=(!((new Occurence()).noOfOccurancesOfLactIOPairMustHaveDiffAliValue((xcb.xpath({field_xpath})).stringValue(),(xcb.xpath({field_xpath})).stringValue())))
[condition][]it is not true that_the {field} is populated=(!((new Populated()).isPopulated((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {pos} position_of {field} field_is_equal_to_values {comma_seperated_values}=(!((new Position()).positionOftagValueEqualToValues({pos},(xcb.xpath({field})).stringValue(),{comma_seperated_values})))
[condition][]the value of{field} is not equal to occurence of the {field_with_xpath}=((new Occurence()).valueOfFieldIsNotEqualToccurenceOfAnotherField((xcb.xpath({field})).stringValue(),(xcb.xpath({field_with_xpath})).stringValue()))
[condition][]it is not true that_checkTagValue  pon{field} ver{field} ccna{field} icsc{field} section{section} tag{tag} equalsvalue{value} pos{pos}InRequestforResponse=(!((new SuplementOrderCheck()).checkTagValueInRequestforResponse((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{section},{tag},{value},{pos})))
[condition][]it is not true that_check previous versison servicetype for the pon {Pon_Field_Value} and version {Ver_Field_Value} and ccna {Ccna_Field_Value} and icsc {Icsc_Field_Value} with current rootnode value {Rootnode_Value}=(!((new SuplementOrderCheck()).checkServiceTypeInPreviousVersion({Pon_Field_Value},{Ver_Field_Value},{Ccna_Field_Value},{Icsc_Field_Value},{Rootnode_Value})))
[condition][]the {field} is Numeric without Special Characters Set {set_of_special_characters}=((new DatatypeCheck()).checkNumericWithOutSPSet((xcb.xpath({field})).stringValue(),{set_of_special_characters}))
[condition][]it is not true that_virtualoccOfF1POPnF2NOTPOPwithinsameUNIMAPPING{section} {errorcode} {field1} {field2} {field3}=(!(virtualoccOfF1POPnF2NOTPOPwithinsameUNIMAPPING({section},{errorcode},(xcb.xpath({field1})).stringValue(),(xcb.xpath({field2})).stringValue(),(xcb.xpath({field3})).stringValue())))
[condition][]it is not true that_the {field} contains numeric values followed by lowercase Alpha Characters=(!((new CapitalLetterCheck()).fieldContainsNumericValuesFollowedByLowercaseAlphaCharacters((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_virtualALCONfieldPopulated{priloc} {secloc} {errorcode}=(!(virtualALCONfieldPopulated({priloc},{secloc},{errorcode})))
[condition][]anyOccurenceOfMultipleFieldIsPopulatedAndNotNumeric{var0}=((new Occurence()).anyOccurenceOfMultipleFieldIsPopulatedAndNotNumeric({var0}))
[condition][]it is not true that_the {field} contains alpha characters=(!((new Contains()).containsAlpha((xcb.xpath({field})).stringValue())))
[condition][]the {field} is Prohibited for {comma_seperated_values}=((new Prohibited()).prohibitedForValues((xcb.xpath({field})).stringValue(),{comma_seperated_values}))
[condition][]allLowerCase{var0}=((new CapitalLetterCheck()).allLowerCase({var0}))
[condition][]it is not true that_responseMaximumLengthCheck{var0} {var1} {var2} {var3}=(!((new Occurence()).responseMaximumLengthCheck({var0},{var1},{var2},{var3})))
[condition][]it is not true that_isCurrentDateLessThanOrEqualToDesiredDueDate{var0}=(!((new DateCheck()).isCurrentDateLessThanOrEqualToDesiredDueDate({var0})))
[condition][]it is not true that_the {field} contains all lowercase alpha characters directly preceded by a numeric character=(!((new CapitalLetterCheck()).lowercaseAlphaCharactersPreceededByNumeric((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} has_date format check1 {format1}=(!((new DateFormatCheck()).dateCheck1((xcb.xpath({field})).stringValue(),{format1})))
[condition][]virtualoccurenceofuactRuid{vector} {list}{errorcode}=((new Occurence()).virtauloccurenceofuactRuid({vector},{list},{errorcode}))
[condition][]it is not true that_the interval between {field_date1} and {field_date2} is greater than or equal to {days}=(!((new DateCheck()).intervalBetweenTwoDateIsGreaterThanOrEqualToDays((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue(),{days})))
[condition][]it is not true that_the {field} is compared with its position {pos1} to {pos2} with values {values}=(!((new Position()).compareCharAtAnyPositionWithAnyNumberOfValue((xcb.xpath({field})).stringValue(),{pos1},{pos2},{values})))
[condition][]the {field} has_the specified segment with number {segnum} whose length is less than specified {length}=((new LengthCheck()).segmentNumberLengthLessThan((xcb.xpath({field})).stringValue(),{segnum},{length}))
[condition][]the {field} has_specified segment {segnum} which contains alpha numeric characters with virgule or period as delimiter=((new DatatypeCheck()).virguleandPeriodSegmentEqualToAlphaNumeric((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]it is not true that_the fields NC {NC} NCI {NCI} and SECNCI {SECNCI} are not compatible with database=(!((new ASOGTABLE()).checkNcNciCompatibility({NC},{NCI},{SECNCI})))
[condition][]it is not true that_the {field} is equal or greater than {value}=(!((new Equals()).isEqualOrGreaterThan((xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_segact of ARI{ari}{segact} and RING{ring} value check with errorcode {errorcode}=(!(virtualSegactValueCheck({ari},{segact},{ring},{errorcode})))
[condition][]it is not true that_positionOfStringInSpecifiedRange{var0} {var1} {var2} {var3}=(!((new RangeOfValues()).PositionOfStringInSpecifiedRange({var0},{var1},{var2},{var3})))
[condition][]it is not true that_the position_of Alpha is {pos} in {field}=(!((new DatatypeCheck()).checkPositionAlpha({pos},(xcb.xpath({field})).stringValue())))
[condition][]check for previous order based on pon and HDRICSC for the pon {pon} ccna{ccna} and icsc{icsc}=((new SuplementOrderCheck()).prevOrderCheckforHdrICSC({pon},{ccna},{icsc}))
[condition][]it is not true that_isValidDate1{var0}=(!((new DateCheck()).isValidDate1({var0})))
[condition][]the {field_with_xpath} is not required=((new Required()).isNotRequired((xcb.xpath({field_with_xpath})).stringValue()))
[condition][]checkAnyPositionsInRangeContainsValues{var0} {var1} {var2} {var3}=((new Position()).checkAnyPositionsInRangeContainsValues({var0},{var1},{var2},{var3}))
[condition][]it is not true that_the interval between {field_date1} and {field_date2} is not equal to {days}=(!((new DateCheck()).intervalBetweenTwoDateIsNotEqualtoDays((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue(),{days})))
[condition][]all tags of unimapping {section} in current and previous version check {sup}{pon}{ver}{ccna}{icsc}{uact}{values}{uref} with {code}=((new Occurence()).VirtualUnimappingTagsCheckWIthPreviousVer({section},{sup},{pon},{ver},{ccna},{icsc},{uact},{values},{uref},{code}))
[condition][]the field {field} is not numeric from postion {posn1} to position {posn2}=((new Contains()).positionalNotNumeric((xcb.xpath({field})).stringValue(),{posn1},{posn2}))
[condition][]atleast any one of the segment delimeted by the char {delim_char} of the {field} does not contain Alpha character followed by maximum number {num} of numeric characters=(virtualSegmentsDoesNotContainsAlphafollowedByNumerics({delim_char},(xcb.xpath({field})).stringValue(),{num}))
[condition][]the CCNA has_license for NCNCICOMPATIBILITY Table=((new SvcType()).getNCNCICompatibilityLicense())
[condition][]containsSpaceInSpecRange{var0} {var1} {var2}=((new Contains()).containsSpaceInSpecRange({var0},{var1},{var2}))
[condition][]noconfirmationOrderCheckDes pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=((new SuplementOrderCheck()).noConfirmationOrderCheckDes({pon},{ver},{ccna},{icsc},{description}))
[condition][]the {section} for lref when uact is not equal to CKT with {errorcode}=(virtuallrefProhibitedWhenUactNotEqualsCNK({section},{errorcode}))
[condition][]the pos {pos} in any of the segment delimeted by the char {delim_char} of the {field} does not equal {comma_separated_values}=(virtualPosOfSegmentsDoesNotEquals({pos},{delim_char},(xcb.xpath({field})).stringValue(),{comma_separated_values}))
[condition][]the {field_value} is present in NCMUX table=((new ASOGTABLE()).fetchAbbreviationNCMUXTable((xcb.xpath({field_value})).stringValue()))
[condition][]it is not true that_noOfOccurancesOfTagValueIsUniqueForAnotherTagValueSet{var0} {var1} {var2}=(!((new Occurence()).noOfOccurancesOfTagValueIsUniqueForAnotherTagValueSet({var0},{var1},{var2})))
[condition][]the {pos} and {pos} of {field} is not_equal_to_values {CommaSeparatedValues}=((new Position()).twoPositionValueofTagNotEqualToValues({pos},{pos},(xcb.xpath({field})).stringValue(),{CommaSeparatedValues}))
[condition][]the field {field} populated with segment {segno} with optional character {character} does not contain {startLength} to {endLength} Alpha Numerics=((new LengthCheck()).checkSegmentNotPopulatedInLengthWithOptionalCharacter((xcb.xpath({field})).stringValue(),{segno},{character},{startLength},{endLength}))
[condition][]it is not true that_the field {field_name} of {parent_name} with value {field_value} differs from previous version tag value for the pon {PON} version {VER} ccna {CCNA} and icsc{ICSC}=(!((new SuplementOrderCheck()).tagValueDiffersInPreviousVersion((xcb.xpath({field_name})).stringValue(),{parent_name},(xcb.xpath({field_value})).stringValue(),{PON},{VER},{CCNA},{ICSC})))
[condition][]the {field} has_all uppercase characters for comma seperated values=((new CapitalLetterCheck()).isAllUpperCaseForCSV((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_atleast one occurence of{section} is populated=(!(virtualsaliAtleastOneOccurenceSectionPopulated1({section})))
[condition][]the difference between {field_date1} and {field_date2} is greater than one year=((new DateCheck()).isRangeGreaterThanOneYear((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue()))
[condition][]it is not true that_any Occurnce of {field_with_xpath} is equal to {character} in {pos}positon=(!((new Occurence()).positionOfAnyFieldEqualToCharacter((xcb.xpath({field_with_xpath})).stringValue(),{character},{pos})))
[condition][]it is not true that_comparePrevVerAndCurrVerFieldValue{var0} {var1} {var2} {var3} {var4} {var5} {var6} {var7} {var8} {var9} {var10}=(!((new SuplementOrderCheck()).comparePrevVerAndCurrVerFieldValue({var0},{var1},{var2},{var3},{var4},{var5},{var6},{var7},{var8},{var9},{var10})))
[condition][]it is not true that_the{section}{subsect}{field} populated and assosiated tag{tag}is not populated or corresponding section tag{corrstag}not equals to {values}=(!(virtualLrefListFieldPopulatedAssoTagIsNotPopulatedOrCorrespondingTagNotEqualsVlaues({section},{subsect},(xcb.xpath({field})).stringValue(),{tag},{corrstag},{values})))
[condition][]routing matrix 1 value check when any ALL is present{section}{subsect}{field}=((new Occurence()).routingMatrixCheck1({section},{subsect},(xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {sectn} has_the naickt{naiSectn} for the cancelled refnum{field} with value{value}=(!(virtualAnyNAICKTcheckForCancelledUREF({sectn},{naiSectn},(xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_the {field} doesnot have {N} number of segments=(!((new LengthCheck()).fieldDoesNothaveNumberOfSegments((xcb.xpath({field})).stringValue(),{N})))
[condition][]it is not true that_the {field_with_xpath} is prohibited=(!((new Prohibited()).isProhibited((xcb.xpath({field_with_xpath})).stringValue())))
[condition][]it is not true that_the {field} is numeric followed by dot and is followed by numeric=(!((new RangeOfValues()).isNumericFollowedByDotFollowedByNumeric((xcb.xpath({field})).stringValue())))
[condition][]allOccurenceOfFieldEqualToValue{var0} {var1}=((new Occurence()).allOccurenceOfFieldEqualToValue({var0},{var1}))
[condition][]it is not true that_any occurence of the {field_with_xpath} is populated in Response=(!((new Occurence()).anyOccurenceOfFieldPopulatedInRespose((xcb.xpath({field_with_xpath})).stringValue())))
[condition][]the {field} has_specified {segmentNumber} field not equal to alpha with virgule or period as delimiter=((new DatatypeCheck()).virguleandPeriodSegmentNotEqualToAlpha((xcb.xpath({field})).stringValue(),{segmentNumber}))
[condition][]the {pos} and {pos} position_of the {field} is greater than or equal to {pos} and {pos} position=((new Position()).twoPositionValueofTagIsGreaterThanOrEqualToTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos}))
[condition][]it is not true that_the {field} is AlphaNumeric with Special Characters=(!((new DatatypeCheck()).checkAlphaNumericSP((xcb.xpath({field})).stringValue())))
[condition][]the {field} at the position {start} to {end} does not contain any Alpha Numeric characters=((new RangeOfValues()).noExistenceOfAlpha_NumericAtSpecRange((xcb.xpath({field})).stringValue(),{start},{end}))
[condition][]the {field} is Prohibited=((new Prohibited()).isProhibited((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_virtualoccOfVPNIDnSVLANSTARTnASNwithinsameUNIMAPPING{section} {errorcode}=(!(virtualoccOfVPNIDnSVLANSTARTnASNwithinsameUNIMAPPING({section},{errorcode})))
[condition][]it is not true that_existenceOfSpaceInEntireRange{field} {range1} {range2}=(!((new SpaceCheck()).existenceOfSpaceInEntireRange((xcb.xpath({field})).stringValue(),{range1},{range2})))
[condition][]it is not true that_the {field_value} is present on ICSC table=(!((new ASOGTABLE()).fetchAbbreviationICSCTable((xcb.xpath({field_value})).stringValue())))
[condition][]it is not true that_the {field} has_not a valid value{comma_seperated_values}=(!((new isValidValue()).isNotValidValue((xcb.xpath({field})).stringValue(),{comma_seperated_values})))
[condition][]the {field} from positions {pos1} to {pos2} is populated or spaces=((new Populated()).rangeOfPositionIsPopulatedOrSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2}))
[condition][]the{section}{field} is not numerics with {errorcode}=((new Occurence()).VirtualResponseDataTypeNumericCheck({section},(xcb.xpath({field})).stringValue(),{errorcode}))
[condition][]the field value {field_value} matches the pattern {pattern}=((new SpecialFormat()).isPatternMatches((xcb.xpath({field_value})).stringValue(),{pattern}))
[condition][]it is not true that_the difference between {field_date1} and {field_date2} is not equal to one year=(!((new DateCheck()).isRangeNotEqualToOneYear((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue())))
[condition][]it is not true that_the_section {section} with field {field} is not unique accross all occurences then errorcode {errorcode}=(!(virtualIsUnique({section},(xcb.xpath({field})).stringValue(),{errorcode})))
[condition][]it is not true that_routing matrix value check{section}{subsect}{field}=(!(virtualRoutingMatrixCheck({section},{subsect},(xcb.xpath({field})).stringValue())))
[condition][]it is not true that_setICSCNCNCICompatibilityLicense {var0}=(!((new SvcType()).setICSCNCNCICompatibilityLicense({var0})))
[condition][]it is not true that_the {field} has_AND which is preceeded and followed by space=(!((new SpaceCheck()).isAndPrecFollSpace((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} has_specified {segmentNumber} not equal to space=(!((new DatatypeCheck()).segmentNotEqualToSpace((xcb.xpath({field})).stringValue(),{segmentNumber})))
[condition][]lrefListFieldPopulatedAssoTagIsNotPopulatedOrCorrespondingTagNotEqualsVlaues{var0} {var1} {var2} {var3} {var4} {var5} {var6}=((new Occurence()).lrefListFieldPopulatedAssoTagIsNotPopulatedOrCorrespondingTagNotEqualsVlaues({var0},{var1},{var2},{var3},{var4},{var5},{var6}))
[condition][]it is not true that_virtualSegmentCount{var0}=(!(virtualSegmentCount({var0})))
[condition][]it is not true that_virtualoccurenceofSvlanMppingfortwoocc{Vector} {errorcode}=(!(virtualoccurenceofSvlanMppingfortwoocc({Vector},{errorcode})))
[condition][]it is not true that_all occurences of{field_with_xpath} not equals to{value}=(!((new Occurence()).allOccurenceOfFieldNotEqualToValue((xcb.xpath({field_with_xpath})).stringValue(),{value})))
[condition][]it is not true that_the {pos} and {pos} of {field} is_equal_to_values {CommaSeparatedValues}=(!((new Position()).twoPositionValueofTagEqualToValues({pos},{pos},(xcb.xpath({field})).stringValue(),{CommaSeparatedValues})))
[condition][]it is not true that_the substring after colon of the {field} equals {values}=(!((new SvcType()).compareSvcTypeAfterColon((xcb.xpath({field})).stringValue(),{values})))
[condition][]it is not true that_the {field_with_xpath} is not prohibited=(!((new Prohibited()).isNotProhibited((xcb.xpath({field_with_xpath})).stringValue())))
[condition][]it is not true that_the {field} having last {N} characters {chars} are preced by numeric=(!((new Equals()).lastNcharsprecededbynumeric((xcb.xpath({field})).stringValue(),{N},{chars})))
[condition][]it is not true that_the {field} contains trailing space character=(!((new SpaceCheck()).checktrailspaces((xcb.xpath({field})).stringValue())))
[condition][]the {field} contains {num} of consecutive lowercase Alpha Characters=((new CapitalLetterCheck()).containsConsecutiveLowercaseAlphaCharacters((xcb.xpath({field})).stringValue(),{num}))
[condition][]the {pos} position_of {field} is in range {start_value} and {end_value}=((new Populated()).isPostionOfFieldPopulatedInRange({pos},(xcb.xpath({field})).stringValue(),{start_value},{end_value}))
[condition][]it is not true that_noconfirmationOrderCheckNew pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}dedicaterecievecustomer{drc}=(!((new SuplementOrderCheck()).noConfirmationOrderCheckNew({pon},{ver},{ccna},{icsc},{description},{drc})))
[condition][]it is not true that_tagValue{var0}=(!((new Occurence()).tagValue({var0})))
[condition][]it is not true that_the {field} is according to the specified {format}=(!((new SpecialFormat()).isFieldAccordingToFormat((xcb.xpath({field})).stringValue(),{format})))
[condition][]it is not true that_the field{field} with segment{segment} equals{value}=(!((new Position()).compareSpecifiedSegmentWithValue((xcb.xpath({field})).stringValue(),{segment},{value})))
[condition][]it is not true that_the {field_value} is populated in segment {segnum} after {value}=(!(virtualPositionAfterDelimeterPopulated((xcb.xpath({field_value})).stringValue(),{segnum},{value})))
[condition][]the field {field} with space in range {start} and {end}=((new SpaceCheck()).existenceOfSpaceInSpecRange((xcb.xpath({field})).stringValue(),{start},{end}))
[condition][]the position {pos1} and {pos2} of {field} is between {start_range} and {end_range}=((new RangeOfValues()).twoFieldPositionInRange({pos1},{pos2},(xcb.xpath({field})).stringValue(),{start_range},{end_range}))
[condition][]it is not true that_the {field} contains {num} of consecutive spaces after Alpha Characters=(!((new CapitalLetterCheck()).containsConsecutiveSpacesAfterAlphaCharacters((xcb.xpath({field})).stringValue(),{num})))
[condition][]it is not true that_virtualCanopiWebService{var0}=(!(virtualCanopiWebService({var0})))
[condition][]the {field} has_the specified segment with number {segnum} whose length is in range {min} to {max} with leading spaces to support virgule or period as delimiter=((new LengthCheck()).virguleandPeriodSegmentRangeIsNumericWithLeadingSpaces((xcb.xpath({field})).stringValue(),{segnum},{min},{max}))
[condition][]it is not true that_{xpath} is unique=(!((new Unique()).isUnique({xpath})))
[condition][]the {field} is less than {value}=((new Equals()).isLessThan((xcb.xpath({field})).stringValue(),{value}))
[condition][]virtualoccurenceofVACTandUACT2{section} {errorcode}=(virtualoccurenceofVACTandUACT2({section},{errorcode}))
[condition][]setNCNCICompatibilityLicense  {var0} =((new SvcType()).setNCNCICompatibilityLicense({var0}))
[condition][]it is not true that_lrefListFieldPopulatedAssoTagIsNotPopulatedOrCorrespondingTagNotEqualsVlaues{var0} {var1} {var2} {var3} {var4} {var5} {var6}=(!((new Occurence()).lrefListFieldPopulatedAssoTagIsNotPopulatedOrCorrespondingTagNotEqualsVlaues({var0},{var1},{var2},{var3},{var4},{var5},{var6})))
[condition][]it is not true that_virtualoccurenceofuactNCIRuid{vector} {list}{ncivalue}{errorcode}=(!(virtualoccurenceofuactNCIRuid({vector},{list},{ncivalue},{errorcode})))
[condition][]responseMaximumLengthCheck{var0} {var1} {var2} {var3}=((new Occurence()).responseMaximumLengthCheck({var0},{var1},{var2},{var3}))
[condition][]numericCheckFormat{var0} {var1} {var2}=((new SpecialFormat()).NumericCheckFormat({var0},{var1},{var2}))
[condition][]noOfOccurancesOfTagValueIsUniqueForAnotherTagValueSet{var0} {var1} {var2}=((new Occurence()).noOfOccurancesOfTagValueIsUniqueForAnotherTagValueSet({var0},{var1},{var2}))
[condition][]it is not true that_noconfirmationOrderCheckDes pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=(!((new SuplementOrderCheck()).noConfirmationOrderCheckDes({pon},{ver},{ccna},{icsc},{description})))
[condition][]it is not true that_the {field} with segment {segnum} is not populated=(!((new Populated()).segmentIsNotPopulated((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]anyOccurenceOfFieldPopulatedAndAssosiatedTagNotEqualsValues{var0} {var1} {var2} {var3} {var4}=((new Occurence()).anyOccurenceOfFieldPopulatedAndAssosiatedTagNotEqualsValues({var0},{var1},{var2},{var3},{var4}))
[condition][]it is not true that_the range of the {field} is A0 to Z9=(!((new RangeOfValues()).rangeCheckA0_Z9((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_duplicateOrder pon {pon} ver {ver} ccna {ccna} icsc {icsc} exists in DB=(!((new SuplementOrderCheck()).duplicateOrderCheck({pon},{ver},{ccna},{icsc})))
[condition][]it is not true that_the {field} has_words seperated by a comma=(!((new DatatypeCheck()).commaPresenceForMoreThanOneWord((xcb.xpath({field})).stringValue())))
[condition][]display the message {field}=((new DisplayMessage()).displayMessage((xcb.xpath({field})).stringValue()))
[condition][]the field {field_name} of {parent_name} with value {field_value} differs from previous version tag value for the pon {PON} version {VER} ccna {CCNA} and icsc{ICSC}=((new SuplementOrderCheck()).tagValueDiffersInPreviousVersion((xcb.xpath({field_name})).stringValue(),{parent_name},(xcb.xpath({field_value})).stringValue(),{PON},{VER},{CCNA},{ICSC}))
[condition][]it is not true that_the pos {pos} in any of the segment delimeted by the char {delim_char} of the {field} does not equal {comma_separated_values}=(!(virtualPosOfSegmentsDoesNotEquals({pos},{delim_char},(xcb.xpath({field})).stringValue(),{comma_separated_values})))
[condition][]it is not true that_the {field} has_specified {segmentNumber} not equal to numeric=(!((new DatatypeCheck()).segmentNotEqualToNumeric((xcb.xpath({field})).stringValue(),{segmentNumber})))
[condition][]it is not true that_the each position_from {pos1} to {pos2} of {field} is not in between {start_range} and {end_range}=(!((new RangeOfValues()).checkPositionsInRangeNotPopulatedInRangeOfValues({pos1},{pos2},(xcb.xpath({field})).stringValue(),{start_range},{end_range})))
[condition][]it is not true that_the ccna{ccna} and icsc{icsc} combination exists=(!((new SuplementOrderCheck()).checkCcnaIcscCombination({ccna},{icsc})))
[condition][]Is the {field_Date1} less than {comparison_Date} in the format {CCYYMMDD}=((new DateFormatCheck()).isFieldDateLessThanComparisonDateInspecifiedFormat((xcb.xpath({field_Date1})).stringValue(),{comparison_Date},{CCYYMMDD}))
[condition][]virtualoccOfF1nF2andVAL1nVAL2withinsameUNIMAPPING{section} {errorcode} {field1} {F1values}  {field2} {F2values} {field3}=(virtualoccOfF1nF2andVAL1nVAL2withinsameUNIMAPPING({section},{errorcode},(xcb.xpath({field1})).stringValue(),{F1values},(xcb.xpath({field2})).stringValue(),{F2values},(xcb.xpath({field3})).stringValue()))
[condition][]it is not true that_noConfirmationOrderCheck{var0} {var1} {var2} {var3}=(!((new SuplementOrderCheck()).noConfirmationOrderCheck({var0},{var1},{var2},{var3})))
[condition][]it is not true that_characterPreceededOrFollowedByNumeric{var0} {var1}=(!((new Contains()).characterPreceededOrFollowedByNumeric({var0},{var1})))
[condition][]the {field} is AlphaNumeric=((new DatatypeCheck()).checkAlphaNumeric((xcb.xpath({field})).stringValue()))
[condition][]the multiple field {field} is not numeric in any occurence=((new Occurence()).dataTypeCheckForMultipleOccuringTag((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the field {field_name} with parent section {parent_name} is populated in previous version for the pon {PON} ver {VER} ccna {CCNA} and icsc {ICSC}=(!((new SuplementOrderCheck()).fieldPopulatedInPreviousVersion((xcb.xpath({field_name})).stringValue(),{parent_name},{PON},{VER},{CCNA},{ICSC})))
[condition][]it is not true that_the {field_value} is in HHMMAHHMMP format and the difference is equal to or greater than {value} hours=(!((new TimeFormatCheck()).appointmentTimeFormatRange((xcb.xpath({field_value})).stringValue(),{value})))
[condition][]it is not true that_setNCLicense {var0}=(!((new SvcType()).setNCLicense({var0})))
[condition][]it is not true that_the {field} has_only one {char} special character present=(!((new DatatypeCheck()).checkRepeationOFSpecialCharacter((xcb.xpath({field})).stringValue(),{char})))
[condition][]setCLLILicense{var0}=((new SvcType()).setCLLILicense({var0}))
[condition][]the ASR Request order exists for the pon {PON}ccna {CCNA} and icsc {ICSC}=((new SuplementOrderCheck()).checkRequestPonExistsInDatabase({PON},{CCNA},{ICSC}))
[condition][]it is not true that_the field value {field_value} do_not_matches the pattern {pattern}=(!((new SpecialFormat()).isPatternNotMatches((xcb.xpath({field_value})).stringValue(),{pattern})))
[condition][]it is not true that_the range of the {field} is AA to ZZ=(!((new RangeOfValues()).rangeCheckAA_ZZ((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_atleast any one of the segment delimeted by the char {delim_char} of the {field} does not contain Alpha character followed by maximum number {num} of numeric characters=(!(virtualSegmentsDoesNotContainsAlphafollowedByNumerics({delim_char},(xcb.xpath({field})).stringValue(),{num})))
[condition][]it is not true that_check for previous order based on pon and HDRICSC for the pon {pon} ccna{ccna} and icsc{icsc}=(!((new SuplementOrderCheck()).prevOrderCheckforHdrICSC({pon},{ccna},{icsc})))
[condition][]segact of ARI{ari}{segact} and RING{ring} value check with errorcode {errorcode}=(virtualSegactValueCheck({ari},{segact},{ring},{errorcode}))
[condition][]the icsc {field_value} has_the license for the table {NC_NCI_ICSC_CLLI}=((new ASOGTABLE()).checkIcscLicenseForTable((xcb.xpath({field_value})).stringValue(),{NC_NCI_ICSC_CLLI}))
[condition][]the {field} has_specified segment {segnum} which contains alpha numeric characters=((new DatatypeCheck()).segmentEqualToAlphaNumeric((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]the pon {PON} ccna {CCNA} and icsc{ICSC} combination has_the response with description {DESCRIPTION} and the previous version SUP1 has_order with status {CURRENTSTATUS} for the xml {xmlins}=(virtual_prevOrderSUP1CheckWithRespReject({PON},{CCNA},{ICSC},{DESCRIPTION},{CURRENTSTATUS},{xmlins}))
[condition][]it is not true that_the difference between {field_date1} and {field_date2} is greater than specified {field_months}=(!((new DateCheck()).isRangeGreaterThanSpecifiedMonths((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue(),(xcb.xpath({field_months})).stringValue())))
[condition][]getLatestValidVersionInDataBaseWithStatus{var0} {var1} {var2}=((new SuplementOrderCheck()).getLatestValidVersionInDataBaseWithStatus({var0},{var1},{var2}))
[condition][]it is not true that_the {field} has_specified {segmentNumber} not equal to numeric with virgule or period as delimiter=(!((new DatatypeCheck()).virguleandPeriodSegmentNotEqualToNumeric((xcb.xpath({field})).stringValue(),{segmentNumber})))
[condition][]it is not true that_the {field} is_equal_to_values {CommaSeparatedValues}=(!((new Equals()).isEqualToValues((xcb.xpath({field})).stringValue(),{CommaSeparatedValues})))
[condition][]cktActCheckWithPrevVer{var0} {var1} {var2} {var3} {var4} {var5} {var6}=((new SuplementOrderCheck()).cktActCheckWithPrevVer({var0},{var1},{var2},{var3},{var4},{var5},{var6}))
[condition][]it is not true that_the {field} has_two or more uppercase alphabets=(!((new CapitalLetterCheck()).twoOrMoreConsecUpperCaseAlpha((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the{section}{subsect}{field}not populated and assosiated tag{tag}is populated and corresponding section tag{corrstag}equals to {values}=(!(virtualLrefListFieldIsNotPopulatedAssoTagIsPopulatedandCorrespondingTagEqualsVlaue({section},{subsect},(xcb.xpath({field})).stringValue(),{tag},{corrstag},{values})))
[condition][]the sup {Sup_Field_Value} is populated with pon {Pon_Field_Value} and version {Ver_Field_Value} and ccna {Ccna_Field_Value} and icsc {Icsc_Field_Value} and the UNIMAPPING section which had the field {Field_Name} of values {comma_separated_values} and with all its elements of the previous order is not equal to none of the UNIMAPPING section with all its elements in current order=((new SuplementOrderCheck()).checkActiveUrefDoesNotExists({Sup_Field_Value},{Pon_Field_Value},{Ver_Field_Value},{Ccna_Field_Value},{Icsc_Field_Value},{Field_Name},{comma_separated_values}))
[condition][]it is not true that (!((new ReqTypeAct()).getRequestType()))=(!((new ReqTypeAct()).getRequestType()))
[condition][]checkCancelledUrefExists{var0} {var1} {var2} {var3} {var4} {var5} {var6}=((new SuplementOrderCheck()).checkCancelledUrefExists({var0},{var1},{var2},{var3},{var4},{var5},{var6}))
[condition][]it is not true that_checkResponsePonDoesNotExistInRequest{var0} {var1} {var2}=(!((new SuplementOrderCheck()).checkResponsePonDoesNotExistInRequest({var0},{var1},{var2})))
[condition][]it is not true that_the table {table_name} does not exists in the data base=(!((new ASOGTABLE()).checkNonExistenceOfTable({table_name})))
[condition][]checkTagValue  pon{field} ver{field} ccna{field} icsc{field} section{section} tag{tag} equalsvalue{value} pos{pos}InRequestforResponse=((new SuplementOrderCheck()).checkTagValueInRequestforResponse((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{section},{tag},{value},{pos}))
[condition][]confirmationOrderCheck{var0} {var1} {var2} {var3}=((new SuplementOrderCheck()).confirmationOrderCheck({var0},{var1},{var2},{var3}))
[condition][]it is not true that_display the message {field}=(!((new DisplayMessage()).displayMessage((xcb.xpath({field})).stringValue())))
[condition][]the difference between {field_date1} and {field_date2} is less than or equal to one year=((new DateCheck()).isRangeLesserThanOrEqualToOneYear((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue()))
[condition][]for the Trading Partner with the ICSC {icsc_value} the {date_value} falls on holiday=((new HOLIDAY()).fetchTPHoliday({icsc_value},{date_value}))
[condition][]it is not true that_the {field_date1} is a working day=(!((new DateCheck()).isWorkingDay((xcb.xpath({field_date1})).stringValue())))
[condition][]the {field} has_none valid values {comma_seperated_values}=((new isValidValue()).isNoneValidValues((xcb.xpath({field})).stringValue(),{comma_seperated_values}))
[condition][]it is not true that_allOccurenceOfFieldEqualToValue{var0} {var1}=(!((new Occurence()).allOccurenceOfFieldEqualToValue({var0},{var1})))
[condition][]the {field} not equal to specified {value} of the specified {segnum}=((new Equals()).segmentValueNotEqualToEnteredValue((xcb.xpath({field})).stringValue(),{value},{segnum}))
[condition][]it is not true that_the occurance of {field_with_xpath} is equal to {number}=(!((new Occurence()).noOfOccurenceEqualTo((xcb.xpath({field_with_xpath})).stringValue(),{number})))
[condition][]the each position_from {pos1} to {pos2} of {field} is not in between {start_range} and {end_range}=((new RangeOfValues()).checkPositionsInRangeNotPopulatedInRangeOfValues({pos1},{pos2},(xcb.xpath({field})).stringValue(),{start_range},{end_range}))
[condition][]it is not true that_the {field}is not_equal_to_values {CommaSeparatedValues}=(!((new Equals()).isNotEqualToValues((xcb.xpath({field})).stringValue(),{CommaSeparatedValues})))
[condition][]the {field} has_a space which is followed by numeric=((new SpaceCheck()).spaceFollowedByNumeric((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_noOfCharactersinTag{var0} {var1} {var2}=(!((new Contains()).NoOfCharactersinTag({var0},{var1},{var2})))
[condition][]it is not true that_the sup {Sup_Field_Value} is populated with pon {Pon_Field_Value} and version {Ver_Field_Value} and ccna {Ccna_Field_Value} and icsc {Icsc_Field_Value} on the current order and does not have same {CCNA_ICSC} on the previous order=(!((new SuplementOrderCheck()).checkCcnaIcscActWithPreviousVersion({Sup_Field_Value},{Pon_Field_Value},{Ver_Field_Value},{Ccna_Field_Value},{Icsc_Field_Value},{CCNA_ICSC})))
[condition][]it is not true that_virtualFSCheckKeyValuePairExists{var0} {var1}=(!((new Occurence()).FS_CheckKeyValuePairExists({var0},{var1})))
[condition][]it is not true that_the CKTACT field check pon{pon}ver{ver}ccna{ccna}icsc{icsc} and xpath{xpath}tag{tag} with value{value} for rule{ruleErrorCode}=(!((new Occurence()).cktActCheck({pon},{ver},{ccna},{icsc},{xpath},{tag},{value},{ruleErrorCode})))
[condition][]it is not true that_the {field} is AlphaNumeric without following Special Character set {set_of_special_characters}=(!((new DatatypeCheck()).checkAlphaNumericWithOutSPSet((xcb.xpath({field})).stringValue(),{set_of_special_characters})))
[condition][]the {field} has_the segment with specified {segnum} whose length is greater than specified {length}=((new LengthCheck()).segmentNumberLengthGreaterThan((xcb.xpath({field})).stringValue(),{segnum},{length}))
[condition][]the {field_date1} is a Holiday=((new DateCheck()).isInHolidayList((xcb.xpath({field_date1})).stringValue()))
[condition][]it is not true that_the{section}{field} is not numerics with {errorcode}=(!((new Occurence()).VirtualResponseDataTypeNumericCheck({section},(xcb.xpath({field})).stringValue(),{errorcode})))
[condition][]section{section} tag{tag} not populated=(virtualNotPopulated({section},{tag}))
[condition][]it is not true that_the {field} has_not a valid values {comma_seperated_values}=(!((new isValidValue()).isNotValidValues((xcb.xpath({field})).stringValue(),{comma_seperated_values})))
[condition][]it is not true that_the {field} has_a valid value {value}=(!((new isValidValue()).isValidValue((xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_spaceFollowedBySpaceFollowedByChar{var0}=(!((new SpaceCheck()).spaceFollowedBySpaceFollowedByChar({var0})))
[condition][]the {field} contains embedded space=((new SpaceCheck()).containsEmbeddedSpace((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} has_the segment with specified {segnum} whose length is greater than specified {length}=(!((new LengthCheck()).segmentNumberLengthGreaterThan((xcb.xpath({field})).stringValue(),{segnum},{length})))
[condition][]it is not true that_the {field} has {comma_seperated_values}=(!((new ValidValueCheck()).validCommaSeperatedValue((xcb.xpath({field})).stringValue(),{comma_seperated_values})))
[condition][]it is not true that_the field {field} populated with segment {segno} with optional character {character} does not contain {startLength} to {endLength} Alpha Numerics=(!((new LengthCheck()).checkSegmentNotPopulatedInLengthWithOptionalCharacter((xcb.xpath({field})).stringValue(),{segno},{character},{startLength},{endLength})))
[condition][]the {field} is AlphaNumeric with following Special Character set {set_of_special_characters}=((new DatatypeCheck()).checkAlphaNumericSPSet((xcb.xpath({field})).stringValue(),{set_of_special_characters}))
[condition][]it is not true that_the {field} contains embedded space=(!((new SpaceCheck()).containsEmbeddedSpace((xcb.xpath({field})).stringValue())))
[condition][]the segment {segnum} length of field {field_value} is in the range {min} and {max}=((new LengthCheck()).segmentNumberLengthInRange({segnum},(xcb.xpath({field_value})).stringValue(),{min},{max}))
[condition][]setIcscCLLILicense {var0}=((new SvcType()).setIcscCLLILicense({var0}))
[condition][]the interval between {field_date1} and {field_date2} is less than {days}=((new DateCheck()).intervalBetweenTwoDateIsLessThanDays((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue(),{days}))
[condition][]checkAlphaNumericWithASingleSpecialCharacter{var0} {var1}=((new DatatypeCheck()).checkAlphaNumericWithASingleSpecialCharacter({var0},{var1}))
[condition][]the {field} has_specified {segmentNumber} not equal to numeric with virgule or period as delimiter=((new DatatypeCheck()).virguleandPeriodSegmentNotEqualToNumeric((xcb.xpath({field})).stringValue(),{segmentNumber}))
[condition][]it is not true that_the {field} is equal or less than {value}=(!((new Equals()).isEqualOrLessThan((xcb.xpath({field})).stringValue(),{value})))
[condition][]the sup {Sup_Field_Value} is populated with pon {Pon_Field_Value} and version {Ver_Field_Value} and ccna {Ccna_Field_Value} and icsc {Icsc_Field_Value} on the current order and does not have same {CCNA_ICSC} on the previous order=((new SuplementOrderCheck()).checkCcnaIcscActWithPreviousVersion({Sup_Field_Value},{Pon_Field_Value},{Ver_Field_Value},{Ccna_Field_Value},{Icsc_Field_Value},{CCNA_ICSC}))
[condition][]the {field} contains {num} of consecutive spaces after Alpha Characters=((new CapitalLetterCheck()).containsConsecutiveSpacesAfterAlphaCharacters((xcb.xpath({field})).stringValue(),{num}))
[condition][]noOfOccurenceGreaterThanValue{var0} {var1}=((new Occurence()).noOfOccurenceGreaterThanValue({var0},{var1}))
[condition][]it is not true that_the {field} is populated with {number_of_segment} segments=(!((new LengthCheck()).numberOfSegments((xcb.xpath({field})).stringValue(),{number_of_segment})))
[condition][]any one of the segment that may be delimeted by the char {delim_char} of the {field} does not contain {Alpha} Alpha character followed by maximum number {num} of numeric characters=((new LengthCheck()).segmentDoesNotContainsAlphaCountFollowedByNumericCount({delim_char},(xcb.xpath({field})).stringValue(),{Alpha},{num}))
[condition][]it is not true that_there is no {section} section=(!((new Populated()).isNotPopulatedSection({section})))
[condition][]it is not true that_the {pos} and {pos} position_of the {field} is equal to {pos} and {pos} position=(!((new Position()).twoPositionValueofTagEqualToValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos})))
[condition][]the {pos} position_of {field} is equal to {value}=((new Position()).positionOftagValueEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value}))
[condition][]existenceOfSpaceInEntireRange{field} {range1} {range2}=((new SpaceCheck()).existenceOfSpaceInEntireRange((xcb.xpath({field})).stringValue(),{range1},{range2}))
[condition][]it is not true that_the {field} has_both uppercase and lowercase characters for commaseperated vaules=(!((new CapitalLetterCheck()).isUpperAndLowerCaseForCSV((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the pos{pos1} to {pos2} of the field {field} with specified segment {segnum} is equal to the pos{pos1} to {pos2} of another field {field}=(!((new Position()).segmentInPositionRangeEqualToNextFieldSpecifiedPositionRange({pos1},{pos2},(xcb.xpath({field})).stringValue(),{segnum},{pos1},{pos2},(xcb.xpath({field})).stringValue())))
[condition][]The fieldDate is a valid date in the format mmddyy=((new DateCheck()).isValidDate2())
[condition][]the version is {VER} not equal to the latest database version for the pon {PON} ccna {CCNA} and icsc{ICSC} with the status {STATUS}=((new SuplementOrderCheck()).verNotEqualToLatestDBVersion({VER},{PON},{CCNA},{ICSC},{STATUS}))
[condition][]duplicateOrder pon {pon} ver {ver} ccna {ccna} icsc {icsc} exists in DB=((new SuplementOrderCheck()).duplicateOrderCheck({pon},{ver},{ccna},{icsc}))
[condition][]the {field_with_xpath} is prohibited=((new Prohibited()).isProhibited((xcb.xpath({field_with_xpath})).stringValue()))
[condition][]the occurance of {field_with_xpath} is less than {number}=((new Occurence()).noOfOccurenceLessThan((xcb.xpath({field_with_xpath})).stringValue(),{number}))
[condition][]it is not true that_getLatestValidVersionInDataBaseWithStatus{var0} {var1} {var2}=(!((new SuplementOrderCheck()).getLatestValidVersionInDataBaseWithStatus({var0},{var1},{var2})))
[condition][]the {field} contains trailing space character=((new SpaceCheck()).checktrailspaces((xcb.xpath({field})).stringValue()))
[condition][]the {field} has_date format as check3 {YYMMDD}=((new DateFormatCheck()).dateCheck3((xcb.xpath({field})).stringValue(),{YYMMDD}))
[condition][]it is not true that_atleast one occurence of{section}{subsectn} is populated=(!(virtualsaliAtleastOneOccurenceSectionPopulated({section},{subsectn})))
[condition][]it is not true that_if {pos1} and {pos2} not in foramt {chhp} for {fdt}=(!((new DateFormatCheck()).time_format_chkforFDT({pos1},{pos2},{chhp},{fdt})))
[condition][]it is not true that_any of the {field_with_xpath} has {character}=(!(virtualanyCharacterOfFieldIs((xcb.xpath({field_with_xpath})).stringValue(),{character})))
[condition][]the {field} has_two or more uppercase alphabets=((new CapitalLetterCheck()).twoOrMoreConsecUpperCaseAlpha((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_anyOccurenceOfFieldPopulatedAndAssosiatedTagNotEqualsValues{var0} {var1} {var2} {var3} {var4}=(!((new Occurence()).anyOccurenceOfFieldPopulatedAndAssosiatedTagNotEqualsValues({var0},{var1},{var2},{var3},{var4})))
[condition][]it is not true that_the_section{section} with the field {field} is not consecutively assigned from value{value} with errorcode {errorcode}=(!(virtualFieldIsNotConsecutivelyAssignedAcrossOccurrences({section},(xcb.xpath({field})).stringValue(),{value},{errorcode})))
[condition][]the {field} is not Required=((new Required()).isNotRequired((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} has_ampersand which is not preceeded and followed by space=(!((new SpaceCheck()).isAmpersandNotPrecFollSpace((xcb.xpath({field})).stringValue())))
[condition][]virtualoccurenceofVACTandUACT {section} {errorcode}=(virtualoccurenceofVACTandUACT({section},{errorcode}))
[condition][]the {field_value} is populated in segment {segnum} after {value}=(virtualPositionAfterDelimeterPopulated((xcb.xpath({field_value})).stringValue(),{segnum},{value}))
[condition][]it is not true that_the difference between {field_date1} and {field_date2} is less than or equal to one year=(!((new DateCheck()).isRangeLesserThanOrEqualToOneYear((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue())))
[condition][]any occurance of {field_with_xpath} is there=((new Occurence()).anyOccurenceOf((xcb.xpath({field_with_xpath})).stringValue()))
[condition][]setSvcNameUOM {var0}=((new SvcType()).setSvcNameUOM({var0}))
[condition][]the {field} is in the range ZL1 to ZL8=((new RangeOfValues()).rangeCheckZl1_Zl8((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the difference between {field_date1} and {field_date2} is greater than one year=(!((new DateCheck()).isRangeGreaterThanOneYear((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue())))
[condition][]it is not true that_the {pos} and {pos} position_of the {field} is greater than {pos} and {pos} position=(!((new Position()).twoPositionValueofTagIsGreaterThanTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos})))
[condition][]it is not true that_the{section} {field} is not unique in all the occurences with code {code}=(!((new Occurence()).isUnique({section},(xcb.xpath({field})).stringValue(),{code})))
[condition][]any occurance of the {field1_with_xpath} is not equal to {value}=((new Occurence()).anyOccurenceNotEqualToValue((xcb.xpath({field1_with_xpath})).stringValue(),{value}))
[condition][]it is not true that_the_section {section} {field} is populated in any occurence with  {errorcode}=(!(virtualFieldIsPopulated({section},(xcb.xpath({field})).stringValue(),{errorcode})))
[condition][]it is not true that_Is the {field} of the specified {segnum} according to the format {format}=(!((new DateFormatCheck()).isSpecifiedSegmentInValidFormat((xcb.xpath({field})).stringValue(),{segnum},{format})))
[condition][]it is not true that_the field {field} has_pattern {pattern}=(!((new SpecialFormat()).patternChecking((xcb.xpath({field})).stringValue(),{pattern})))
[condition][]it is not true that_the {field} is Prohibited=(!((new Prohibited()).isProhibited((xcb.xpath({field})).stringValue())))
[condition][]the {field} has_specified {segmentNumber} not equal to space=((new DatatypeCheck()).segmentNotEqualToSpace((xcb.xpath({field})).stringValue(),{segmentNumber}))
[condition][]the field value {field_value} do_not_matches the pattern {pattern}=((new SpecialFormat()).isPatternNotMatches((xcb.xpath({field_value})).stringValue(),{pattern}))
[condition][]the {field} has_all uppercase characters=((new CapitalLetterCheck()).isAllUpperCase((xcb.xpath({field})).stringValue()))
[condition][]the {field} has_from the start position {pos} to end position {pos} the constant {constant} followed by a Dot and followed by {number} alphanumeric characters=((new DatatypeCheck()).constantFollowedByDotFollowedByAlphaNumeric((xcb.xpath({field})).stringValue(),{pos},{pos},{constant},{number}))
[condition][]positionOfAllFieldNotEqualToCharacter{var0} {var1} {var2}=((new Occurence()).positionOfAllFieldNotEqualToCharacter({var0},{var1},{var2}))
[condition][]it is not true that_the {field} has_valid values {comma_seperated_values}=(!((new isValidValue()).isValidValues((xcb.xpath({field})).stringValue(),{comma_seperated_values})))
[condition][]there is no {section} section=((new Populated()).isNotPopulatedSection({section}))
[condition][]the {pos} to {pos} of the {field_1} is equal to {pos} to {pos} of the {field_2}=((new Position()).twoPositionRangeValueofTagEqualToValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field_1})).stringValue(),{pos},{pos},(xcb.xpath({field_2})).stringValue()))
[condition][]it is not true that_the {field} contains {CommaSeparatedValues}=(!((new Contains()).contains((xcb.xpath({field})).stringValue(),{CommaSeparatedValues})))
[condition][]routing matrix value check when any ALL is present{section}{subsect}{field}=(virtualRoutingMatrixCheck1({section},{subsect},(xcb.xpath({field})).stringValue()))
[condition][]it is not true that_anyOccurenceSection{sect}WithTag1{tag1}NotpopulatedAndTag2{tag2}Populatedwith errorcode{errorcode}=(!(virtualanyOccurenceWithTag1NotpopulatedAndTag2Populated({sect},{tag1},{tag2},{errorcode})))
[condition][]the order is a resend order=((new SuplementOrderCheck()).resendOrderCheck())
[condition][]the {field} has_the segment with specified {segnum} whose length is greater than specified {length} to support virgule or period=((new LengthCheck()).virguleandPeriodSegmentNumberLengthGreaterThan((xcb.xpath({field})).stringValue(),{segnum},{length}))
[condition][]atleast one occurence of{section} is populated=(virtualsaliAtleastOneOccurenceSectionPopulated1({section}))
[condition][]noconfirmationOrderCheck pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=((new SuplementOrderCheck()).noConfirmationOrderCheck({pon},{ver},{ccna},{icsc},{description}))
[condition][]the {field} is not numeric with special character set{sp_characters}=((new DatatypeCheck()).notNumericWithAllSpSet((xcb.xpath({field})).stringValue(),{sp_characters}))
[condition][]it is not true that_the field {field} with space in range {start} and {end}=(!((new SpaceCheck()).existenceOfSpaceInSpecRange((xcb.xpath({field})).stringValue(),{start},{end})))
[condition][]the {field} is in the range A1 to Z99=((new RangeOfValues()).rangeCheckA1_Z99((xcb.xpath({field})).stringValue()))
[condition][]the range of the {field} is A0 to Z9=((new RangeOfValues()).rangeCheckA0_Z9((xcb.xpath({field})).stringValue()))
[condition][]confirmationOrderCheckDes pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=((new SuplementOrderCheck()).confirmationOrderCheckDes({pon},{ver},{ccna},{icsc},{description}))
[condition][]it is not true that_the {field} is not Required=(!((new Required()).isNotRequired((xcb.xpath({field})).stringValue())))
[condition][]the version {VER} is not one greater than the previous database version for the pon {PON} ccna {CCNA} and icsc {ICSC} with status {status}=((new SuplementOrderCheck()).verNotOneGreaterThanLatestDBVersion({VER},{PON},{CCNA},{ICSC},{status}))
[condition][]it is not true that_virtualoccurenceofuactRuid{vector} {list}{errorcode}=(!((new Occurence()).virtauloccurenceofuactRuid({vector},{list},{errorcode})))
[condition][]the {field} has_specified segment {segnum} which contains alpha numeric characters with space=((new DatatypeCheck()).segmentEqualToAlphaNumericWithSpace((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]all occurences of{field_with_xpath} not equals to{value}=((new Occurence()).allOccurenceOfFieldNotEqualToValue((xcb.xpath({field_with_xpath})).stringValue(),{value}))
[condition][]noOfOccurence{var0}=((new Occurence()).noOfOccurence({var0}))
[condition][]the substring after colon of the {field} equals {values}=((new SvcType()).compareSvcTypeAfterColon((xcb.xpath({field})).stringValue(),{values}))
[condition][]it is not true that_allLowerCase{var0}=(!((new CapitalLetterCheck()).allLowerCase({var0})))
[condition][]((new SvcType()).getSvcName())=((new SvcType()).getSvcName())
[condition][]the {pos} position_of {field} is not_equal_to_values {comma_seperated_values}=(virtualPositionOftagValueNotEqualToValues({pos},(xcb.xpath({field})).stringValue(),{comma_seperated_values}))
[condition][]it is not true that_the {field} from positions {pos1} to {pos2} is populated or not spaces=(!((new Populated()).rangeOfPositionIsPopulatedOrNotSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2})))
[condition][]it is not true that_virtualoccOfF1nF2andVAL1nVAL2withinsameUNIMAPPING{section} {errorcode} {field1} {F1values}  {field2} {F2values} {field3}=(!(virtualoccOfF1nF2andVAL1nVAL2withinsameUNIMAPPING({section},{errorcode},(xcb.xpath({field1})).stringValue(),{F1values},(xcb.xpath({field2})).stringValue(),{F2values},(xcb.xpath({field3})).stringValue())))
[condition][]it is not true that_the {field} has_no values{comma_seperated_values} in the segment{segnum} to support virgule or period as delimiter=(!((new Equals()).virguleandPeriodSegmentValueNotEqualToValues((xcb.xpath({field})).stringValue(),{comma_seperated_values},{segnum})))
[condition][]it is not true that_the {field} has_three consecutive uppercase alphabets=(!((new CapitalLetterCheck()).threeConsecutiveUpperCaseAlpha((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} has_all lowercase characters for comma seperated values=(!((new CapitalLetterCheck()).isAllLowerCaseForCSV((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_Request PON{pon} VER{ver} CCNA{ccna} ICSC{icsc} exists in DB=(!((new SuplementOrderCheck()).checkRequestExistsInDatabase({pon},{ver},{ccna},{icsc})))
[condition][]virtualoccOfVPNIDnSVLANSTARTnASNwithinsameUNIMAPPING{section} {errorcode}=(virtualoccOfVPNIDnSVLANSTARTnASNwithinsameUNIMAPPING({section},{errorcode}))
[condition][]the {field} has_date format as {format}=((new DateFormatCheck()).dateCheck((xcb.xpath({field})).stringValue(),{format}))
[condition][]((new ReqTypeAct()).getActivity())=((new ReqTypeAct()).getActivity())
[condition][]it is not true that_the {field_date1} is equal to {field_date2}=(!((new DateCheck()).isEqualTo((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue())))
[condition][]alloccuranceof field{path} not equals values{comma_seperated_values}=((new Occurence()).allOccurenceOfFieldNotEqualsValues({path},{comma_seperated_values}))
[condition][]the {field} is Required for {comma_seperated_values}=((new Required()).requiredForValues((xcb.xpath({field})).stringValue(),{comma_seperated_values}))
[condition][]the {field_date1} is greater than or equal to {field_date2}=((new DateCheck()).isGreaterThanOrEqualTo((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue()))
[condition][]the range of the {field} is AA to ZZ=((new RangeOfValues()).rangeCheckAA_ZZ((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} has_comma seperated values=(!((new CommaSeparatedSpace()).checkCommaSeparatedSpace((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_all occurences of {section} of field {field} equals the value{value} with errorcode {errorcode}=(!(virtualAllOccurenceOfFieldEqualsValue({section},(xcb.xpath({field})).stringValue(),{value},{errorcode})))
[condition][]it is not true that_the {field} is Numeric with Special Characters Set {set_of_special_characters}=(!((new DatatypeCheck()).checkNumericSPSet((xcb.xpath({field})).stringValue(),{set_of_special_characters})))
[condition][]virtualFSCheckKeyValuePairExists{var0} {var1}=((new Occurence()).FS_CheckKeyValuePairExists({var0},{var1}))
[condition][]it is not true that_the sup {Sup_Field_Value} is populated with act {Act_Field_Value} and pon {Pon_Field_Value} and version {Ver_Field_Value} and ccna {Ccna_Field_Value} and icsc {Icsc_Field_Value} on the current order and does not have same ACT on the previous order=(!((new SuplementOrderCheck()).actFieldCheck({Sup_Field_Value},{Act_Field_Value},{Pon_Field_Value},{Ver_Field_Value},{Ccna_Field_Value},{Icsc_Field_Value})))
[condition][]any of the occurance of {field_with_xpath} exists=((new Occurence()).anyOccurenceExists((xcb.xpath({field_with_xpath})).stringValue()))
[condition][]{xpath} is unique=((new Unique()).isUnique({xpath}))
[condition][]it is not true that_the order is a resend order=(!((new SuplementOrderCheck()).resendOrderCheck()))
[condition][]virtualCanopiWebService{var0}=(virtualCanopiWebService({var0}))
[condition][]the pon{field} ver{field} section{section} tag{tag} is populated in Request against Response=((new SuplementOrderCheck()).checkResponseTagExistInRequest((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{section},{tag}))
[condition][]it is not true that_AnyOccoffield1withsection{multiecoec} field1 {OECICSC}equals field2{field2} with values {value1} and {value2} with errorCode {errorcode}=(!(virtualAnyOccoffield1equalsvaluewherefield2notequalsvalue({multiecoec},{OECICSC},(xcb.xpath({field2})).stringValue(),{value1},{value2},{errorcode})))
[condition][]the {field} has_time format as {time_format}=((new TimeFormatCheck()).timeFormat((xcb.xpath({field})).stringValue(),{time_format}))
[condition][]anyOccurenceSection{sect}WithTag1{tag1}NotpopulatedAndTag2{tag2}Populatedwith errorcode{errorcode}=(virtualanyOccurenceWithTag1NotpopulatedAndTag2Populated({sect},{tag1},{tag2},{errorcode}))
[condition][]virtualOccurenceofEIandUACTinUNIMAPPING{section} {errorcode}=(virtualOccurenceofEIandUACTinUNIMAPPING({section},{errorcode}))
[condition][]the {field} contains numeric values followed by lowercase Alpha Characters=((new CapitalLetterCheck()).fieldContainsNumericValuesFollowedByLowercaseAlphaCharacters((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} from {pos1} to {pos2} of the segment{segnum} has_the comma seperated values{values} to support virgule or period as delimiter=(!((new LengthCheck()).virguleandPeriodPosToPosOfSegmentNotEquals((xcb.xpath({field})).stringValue(),{pos1},{pos2},{segnum},{values})))
[condition][]it is not true that_the{section}{field} lengths not equals{value} with code {code}=(!(virtualResponseLengthCheck({section},(xcb.xpath({field})).stringValue(),{value},{code})))
[condition][]it is not true that_Number of occurence of Field {Field_Xpath} is in range from {min_value} To {max_value}=(!((new Occurence()).noOfOccurenceOfFieldInRange({Field_Xpath},{min_value},{max_value})))
[condition][]the {field} has_all lowercase characters=((new CapitalLetterCheck()).isAllLowerCase((xcb.xpath({field})).stringValue()))
[condition][]characterFollowedBySpace{var0} {var1}=((new Contains()).characterFollowedBySpace({var0},{var1}))
[condition][]the {field_date1} is not equal to {field_date2}=((new DateCheck()).isNotEqualTo((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue()))
[condition][]it is not true that_the {field} is AlphaNumeric=(!((new DatatypeCheck()).checkAlphaNumeric((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_any occurence of{field_with_xpath} is not populated=(!((new Occurence()).anyOccurenceOfFieldNotPopulated((xcb.xpath({field_with_xpath})).stringValue())))
[condition][]the_length_of {field} is between {min} and {max} values=((new LengthCheck()).checkMinMaxLength((xcb.xpath({field})).stringValue(),{min},{max}))
[condition][]the value of {field1_with_xpath} is equal to number of occurance of {field2_with_xpath}=((new Occurence()).tagValueOfOneFieldEqualToNoOfOccurenceOfAnotherField((xcb.xpath({field1_with_xpath})).stringValue(),(xcb.xpath({field2_with_xpath})).stringValue()))
[condition][]it is not true that_getvalue{var0}=(!((new Occurence()).getvalue({var0})))
[condition][]the fields NC {NC} NCI {NCI} and SECNCI {SECNCI} are not compatible with database=((new ASOGTABLE()).checkNcNciCompatibility({NC},{NCI},{SECNCI}))
[condition][]anyARIPrilocAndPrilocSpotCheck{var0} {var1} {var2}=((new Occurence()).anyARIPrilocAndPrilocSpotCheck({var0},{var1},{var2}))
[condition][]virtualoccurenceofVACTandUACTCEVLAN{var0} {var1}=(virtualoccurenceofVACTandUACTCEVLAN({var0},{var1}))
[condition][]it is not true that_the {field} from positions {pos1} to {pos2} is not populated or spaces=(!((new Populated()).rangeOfPositionIsNotPopulatedOrSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2})))
[condition][]it is not true that_the difference between {field_date1} and {field_date2} is greater than or equal to one year=(!((new DateCheck()).isRangeGreaterThanOrEqualToOneYear((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue())))
[condition][]it is not true that_The {field} contains whitespaces or numbers in range or zeros from second position_to end=(!((new Position()).charAtPositionCheck((xcb.xpath({field})).stringValue())))
[condition][]the sup {Sup_Field_Value} is populated with act {Act_Field_Value} and pon {Pon_Field_Value} and version {Ver_Field_Value} and ccna {Ccna_Field_Value} and icsc {Icsc_Field_Value} on the current order and does not have same ACT on the previous order=((new SuplementOrderCheck()).actFieldCheck({Sup_Field_Value},{Act_Field_Value},{Pon_Field_Value},{Ver_Field_Value},{Ccna_Field_Value},{Icsc_Field_Value}))
[condition][]virtualoccurenceofVACTandUACT3CEVLAN{var0} {var1}=(virtualoccurenceofVACTandUACT3CEVLAN({var0},{var1}))
[condition][]virtualoccurenceofVACTandUACT2CEVLAN{var0} {var1}=(virtualoccurenceofVACTandUACT2CEVLAN({var0},{var1}))
[condition][]it is not true that_any occurance of {field_with_xpath} is there=(!((new Occurence()).anyOccurenceOf((xcb.xpath({field_with_xpath})).stringValue())))
[condition][]the occurance of {field_with_xpath} is greaterthan {number}=((new Occurence()).noOfOccurenceGreaterThan((xcb.xpath({field_with_xpath})).stringValue(),{number}))
[condition][]occurenceOfFieldIsGreaterThanSpecifiedNumberWithGivenValue{var0} {var1} {var2}=((new Occurence()).occurenceOfFieldIsGreaterThanSpecifiedNumberWithGivenValue({var0},{var1},{var2}))
[condition][]the {field_value} is present in NC table=((new ASOGTABLE()).fetchAbbreviationNCTable((xcb.xpath({field_value})).stringValue()))
[condition][]it is not true that_Is the {field} of the specified segment {segnum} is in the range 00 999=(!((new RangeOfValues()).segmentRangeCheck00_999((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]any occurence of the {field_with_xpath} is populated in Response=((new Occurence()).anyOccurenceOfFieldPopulatedInRespose((xcb.xpath({field_with_xpath})).stringValue()))
[condition][]it is not true that_the {pos} and {pos} position_of the {field} is lesser than or equal to {pos} and {pos} position=(!((new Position()).twoPositionValueofTagIsLessThanOrEqualToTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos})))
[condition][]the interval duration is blank for the {nc}=((new IntervalDurationMatcher()).isIntervalExisting({nc}))
[condition][]any of the {field_with_xpath} has {character}=(virtualanyCharacterOfFieldIs((xcb.xpath({field_with_xpath})).stringValue(),{character}))
[condition][]positionOfAnyFieldNotEqualToCharacter{var0} {var1} {var2}=((new Occurence()).positionOfAnyFieldNotEqualToCharacter({var0},{var1},{var2}))
[condition][]asogCutOverOrderReject{ver} {icsc}{msg_time_stamp}=((new AsogGuidelineVersion()).asogCutOverOrderReject({ver},{icsc},{msg_time_stamp}))
[condition][]it is not true that_the CCNA has_license for NCNCICOMPATIBILITY Table=(!((new SvcType()).getNCNCICompatibilityLicense()))
[condition][]the {field} has_valid values {comma_seperated_values}=((new isValidValue()).isValidValues((xcb.xpath({field})).stringValue(),{comma_seperated_values}))
[condition][]it is not true that_the {field_date1} is a Holiday=(!((new DateCheck()).isInHolidayList((xcb.xpath({field_date1})).stringValue())))
[condition][]any Occurnce of {field_with_xpath} is equal to {character} in {pos}positon=((new Occurence()).positionOfAnyFieldEqualToCharacter((xcb.xpath({field_with_xpath})).stringValue(),{character},{pos}))
[condition][]any occurence of {section}{field} is not populated with  {errorcode}=((new Occurence()).VirtualAnyOccurenceIsNotPopulated({section},(xcb.xpath({field})).stringValue(),{errorcode}))
[condition][]the {field} contains alpha characters=((new Contains()).containsAlpha((xcb.xpath({field})).stringValue()))
[condition][]the {field}is not_equal_to_values {CommaSeparatedValues}=((new Equals()).isNotEqualToValues((xcb.xpath({field})).stringValue(),{CommaSeparatedValues}))
[condition][]it is not true that_timeRange{var0} {var1} {var2}=(!((new TimeFormatCheck()).timeRange({var0},{var1},{var2})))
[condition][]the_section{section} with the field {field} is not consecutively assigned from value{value} with errorcode {errorcode}=(virtualFieldIsNotConsecutivelyAssignedAcrossOccurrences({section},(xcb.xpath({field})).stringValue(),{value},{errorcode}))
[condition][]it is not true that_the value of {field} not equals the occurences of{section}{subsectn}=(!(virtualsaliValueOfFieldNotEqualsOccurenceOfOtherSection((xcb.xpath({field})).stringValue(),{section},{subsectn})))
[condition][]it is not true that_the {field} contains numeric characters=(!((new Contains()).containsNumeric((xcb.xpath({field})).stringValue())))
[condition][]the pos{pos1} to {pos2} of the field {field} with specified segment {segnum} is equal to the pos{pos1} to {pos2} of another field {field}=((new Position()).segmentInPositionRangeEqualToNextFieldSpecifiedPositionRange({pos1},{pos2},(xcb.xpath({field})).stringValue(),{segnum},{pos1},{pos2},(xcb.xpath({field})).stringValue()))
[condition][]it is not true that_setNCILicense {var0}=(!((new SvcType()).setNCILicense({var0})))
[condition][]the difference between {field_date1} and {field_date2} is greater than or equal to one year=((new DateCheck()).isRangeGreaterThanOrEqualToOneYear((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue()))
[condition][]the {field} has_three consecutive uppercase alphabets=((new CapitalLetterCheck()).threeConsecutiveUpperCaseAlpha((xcb.xpath({field})).stringValue()))
[condition][]the difference for the given {CCNA} {NC} and {ICSC} between the {ASR_DDD} and the current date  is less than  the Interval Duration from the table=((new IntervalDurationMatcher()).isIntervalDurationMatching({CCNA},{NC},{ICSC},{ASR_DDD}))
[condition][]the {field_value} is present in the LOCATION table=((new ASOGTABLE()).fetchAbbreviationLOCATIONTable((xcb.xpath({field_value})).stringValue()))
[condition][]confirmationOrderCheck pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=((new SuplementOrderCheck()).confirmationOrderCheck({pon},{ver},{ccna},{icsc},{description}))
[condition][]it is not true that_the{section}{field}is populated and assosiated tag{tag} not equals to values{values}=(!(virtualAnyOccurenceOfFieldPopulatedAndAssosiatedTagNotEqualsValues({section},(xcb.xpath({field})).stringValue(),{tag},{values})))
[condition][]the {sectn} has_the naickt{naiSectn} for the cancelled refnum{field} with value{value}=(virtualAnyNAICKTcheckForCancelledUREF({sectn},{naiSectn},(xcb.xpath({field})).stringValue(),{value}))
[condition][]no of occurences of tag {field_xpath1} with {field1} and {field_xpath2} with {field2} are equal=((new Occurence()).noOfOccurencesOfBothTagAreEqualForSpecifiedPairValue((xcb.xpath({field_xpath1})).stringValue(),(xcb.xpath({field1})).stringValue(),(xcb.xpath({field_xpath2})).stringValue(),(xcb.xpath({field2})).stringValue()))
[condition][]it is not true that_spaceOrCharacterOrNumberInRange0199{var0} {var1} {var2} {var3} {var4}=(!((new Position()).spaceOrCharacterOrNumberInRange01_99({var0},{var1},{var2},{var3},{var4})))
[condition][]the {field} has_specified range {start} to {end}=((new RangeOfValues()).rangeCheckNN_NN((xcb.xpath({field})).stringValue(),{start},{end}))
[condition][]the {field} is AlphaNumeric with Special Characters=((new DatatypeCheck()).checkAlphaNumericSP((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} has_specified segment {segnum} which contains alpha numeric characters with space=(!((new DatatypeCheck()).segmentEqualToAlphaNumericWithSpace((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]it is not true that_The number of occurence of {path} populated is greater than {number}=(!((new Occurence()).NumberOfoccurencepopulatedisgreaterthan({path},{number})))
[condition][]it is not true that_the maximum length of the trimmed field {field_value} is {length}=(!(virtualCheckMaximumLengthOfTrimmedTag((xcb.xpath({field_value})).stringValue(),{length})))
[condition][]it is not true that_isRequired{var0}=(!((new Required()).isRequired({var0})))
[condition][]it is not true that_checkCancelledUrefExists{var0} {var1} {var2} {var3} {var4} {var5} {var6}=(!((new SuplementOrderCheck()).checkCancelledUrefExists({var0},{var1},{var2},{var3},{var4},{var5},{var6})))
[condition][]the_section{section} parent{parent} tag {tag} does not have value{value} in any occurence=(virtualNoneOccurenceEqualsValue({section},{parent},{tag},{value}))
[condition][]it is not true that_virtualisIntervalDurationMatchingForNc{var0} {var1}=(!(virtualisIntervalDurationMatchingForNc({var0},{var1})))
[condition][]it is not true that_the {field_value} not equal to specified values {CommaSeparatedValues} of the specified {segnum}=(!((new Equals()).segmentValueNotEqualToValues((xcb.xpath({field_value})).stringValue(),{CommaSeparatedValues},{segnum})))
[condition][]it is not true that_the {field_date1} is not equal to {field_date2}=(!((new DateCheck()).isNotEqualTo((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue())))
[condition][]the {field} is_equal_to_values {CommaSeparatedValues}=((new Equals()).isEqualToValues((xcb.xpath({field})).stringValue(),{CommaSeparatedValues}))
[condition][]it is not true that_all tags of unimapping {section} in current and previous version check {sup}{pon}{ver}{ccna}{icsc}{uact}{values}{uref} with {code}=(!((new Occurence()).VirtualUnimappingTagsCheckWIthPreviousVer({section},{sup},{pon},{ver},{ccna},{icsc},{uact},{values},{uref},{code})))
[condition][]the {field_with_xpath} occurance is atleast {number_of_times}=((new Occurence()).atleastOccurenceOf((xcb.xpath({field_with_xpath})).stringValue(),{number_of_times}))
[condition][]it is not true that_the {field_value} is present in NCMUX table=(!((new ASOGTABLE()).fetchAbbreviationNCMUXTable((xcb.xpath({field_value})).stringValue())))
[condition][]the {field} has_AND which is preceeded and followed by space=((new SpaceCheck()).isAndPrecFollSpace((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {pos} position_of {field} is not equal to {value}=(!(virtualPositionOftagValueNotEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value})))
[condition][]routing matrix value check{section}{subsect}{field}=(virtualRoutingMatrixCheck({section},{subsect},(xcb.xpath({field})).stringValue()))
[condition][]it is not true that_routing matrix 1 value check when any ALL is present{section}{subsect}{field}=(!((new Occurence()).routingMatrixCheck1({section},{subsect},(xcb.xpath({field})).stringValue())))
[condition][]it is not true that_segmentRangeIsNumericWithLeadingSpaces{var0} {var1} {var2} {var3}=(!((new LengthCheck()).segmentRangeIsNumericWithLeadingSpaces({var0},{var1},{var2},{var3})))
[condition][]the CCNA has_license for NCI Table=((new SvcType()).getNCILicense())
[condition][]it is not true that_segmentEqualToAlphaNumericWithSPChar{var0} {var1} {var2}=(!((new DatatypeCheck()).segmentEqualToAlphaNumericWithSPChar({var0},{var1},{var2})))
[condition][]atleast one occurence of{section}{subsectn} is populated=(virtualsaliAtleastOneOccurenceSectionPopulated({section},{subsectn}))
[condition][]the position_of Alpha is {pos} in {field}=((new DatatypeCheck()).checkPositionAlpha({pos},(xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} is Numeric with Special Characters=(!((new DatatypeCheck()).checkNumericSP((xcb.xpath({field})).stringValue())))
[condition][]the {field} has_comma seperated values=((new CommaSeparatedSpace()).checkCommaSeparatedSpace((xcb.xpath({field})).stringValue()))
[condition][]the sup {Sup_Field_Value} is populated with pon {Pon_Field_Value} and version {Ver_Field_Value} and ccna {Ccna_Field_Value} and icsc {Icsc_Field_Value} on the current order and matching with the previous order which has_a status CANCEL=((new SuplementOrderCheck()).supFieldCheck({Sup_Field_Value},{Pon_Field_Value},{Ver_Field_Value},{Ccna_Field_Value},{Icsc_Field_Value}))
[condition][]it is not true that_the {field} has_time format as {time_format}=(!((new TimeFormatCheck()).timeFormat((xcb.xpath({field})).stringValue(),{time_format})))
[condition][]it is not true that_valueOfFieldIsOneGreaterThanOccurenceOfAnotherField{var0} {var1}=(!((new Occurence()).valueOfFieldIsOneGreaterThanOccurenceOfAnotherField({var0},{var1})))
[condition][]it is not true that_the interval between {field_date1} and {field_date2} is less than or equal to {days}=(!((new DateCheck()).intervalBetweenTwoDateIsLessThanOrEqualtoDays((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue(),{days})))
[condition][]the {field} has_format as {format}=((new SpecialFormat()).formatIs((xcb.xpath({field})).stringValue(),{format}))
[condition][]((new SuplementOrderCheck()).checkTagValueInRequestforResponse())=((new SuplementOrderCheck()).checkTagValueInRequestforResponse())
[condition][]it is not true that_anyOccurenceOfMultipleFieldIsPopulatedAndNotNumeric{var0}=(!((new Occurence()).anyOccurenceOfMultipleFieldIsPopulatedAndNotNumeric({var0})))
[condition][]the {field} has_all lowercase characters for comma seperated values=((new CapitalLetterCheck()).isAllLowerCaseForCSV((xcb.xpath({field})).stringValue()))
[condition][]virtualoccurenceofSvlanMppingfortwoocc{Vector} {errorcode}=(virtualoccurenceofSvlanMppingfortwoocc({Vector},{errorcode}))
[condition][]virtualoccurenceofuactNCI{vector} {list}{ncivalue}{errorcode}=(virtualoccurenceofuactNCI({vector},{list},{ncivalue},{errorcode}))
[condition][]it is not true that_isCurrentDateLessThanOrNotEqualToDesiredDueDate{var0}=(!((new DateCheck()).isCurrentDateLessThanOrNotEqualToDesiredDueDate({var0})))
[condition][]it is not true that_the {field} has_the specified {value} in the range {start} to {end}=(!((new RangeOfValues()).compareSpecStringInRange((xcb.xpath({field})).stringValue(),{value},{start},{end})))
[condition][]the interval between {field_date1} and {field_date2} is greater than or equal to {days}=((new DateCheck()).intervalBetweenTwoDateIsGreaterThanOrEqualToDays((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue(),{days}))
[condition][]the {field} is numeric with trailing spaces=((new DatatypeCheck()).checkNumericWithTrailingSPacesOnly((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} has_a space which is followed by numeric=(!((new SpaceCheck()).spaceFollowedByNumeric((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_lrefTagCheck{var0} {var1} {var2} {var3}=(!((new SuplementOrderCheck()).lrefTagCheck({var0},{var1},{var2},{var3})))
[condition][]it is not true that_the interval between {field_date1} and {field_date2} is less than {days}=(!((new DateCheck()).intervalBetweenTwoDateIsLessThanDays((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue(),{days})))
[condition][]it is not true that_the {field_value} is present in NCI table=(!((new ASOGTABLE()).fetchAbbreviationNCITable((xcb.xpath({field_value})).stringValue())))
[condition][]it is not true that_the_section EVC {section} with subsection {subsect} for the field {field} is not conecutively assigned starting with {value} then errorcode {errorcode}=(!(virtuallrefIsNotConecutivelyAssignedStratingWIthValue({section},{subsect},(xcb.xpath({field})).stringValue(),{value},{errorcode})))
[condition][]virtualoccOfOTCnEVMPIDwithinsameUNIMAPPING{section} {errorcode}=(virtualoccOfOTCnEVMPIDwithinsameUNIMAPPING({section},{errorcode}))
[condition][]comparePrevVerAndCurrVerFieldValue{var0} {var1} {var2} {var3} {var4} {var5} {var6} {var7} {var8} {var9} {var10}=((new SuplementOrderCheck()).comparePrevVerAndCurrVerFieldValue({var0},{var1},{var2},{var3},{var4},{var5},{var6},{var7},{var8},{var9},{var10}))
[condition][]the {field} is compared with the specified positions {pos1} to {pos2} with values {value1} or {value2}=((new Position()).compareCharAtAnyPositionWithAnyValue((xcb.xpath({field})).stringValue(),{pos1},{pos2},{value1},{value2}))
[condition][]it is not true that_the {field} contains {num} of spaces before Alpha Characters=(!((new CapitalLetterCheck()).containsConsecutiveSpacesBeforeAlphaCharacters((xcb.xpath({field})).stringValue(),{num})))
[condition][]the ICSC has_license for NCNCICOMPATIBILITY Table=((new SvcType()).getIcscCLLILicense())
[condition][]any occurence of the {field_with_xpath} is not populated in Response=((new Occurence()).anyOccurenceOfFieldNotPopulatedinResponse((xcb.xpath({field_with_xpath})).stringValue()))
[condition][]Is the {field} of the specified segment {segnum} is in the range 00 999=((new RangeOfValues()).segmentRangeCheck00_999((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]it is not true that_the {pos} position_Of {field} equal to {value}=(!((new Contains()).positionOfFieldEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_the last character Of {field} is {value}=(!((new Equals()).lastCharacterOfField((xcb.xpath({field})).stringValue(),{value})))
[condition][]the {field} is greater than {value}=((new Equals()).isGreaterThan((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the {pos} and {pos} position_of the {field} is not equal to {pos} and {pos} position=(!((new Position()).twoPositionValueofTagNotEqualToValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos})))
[condition][]noConfirmationOrderCheck{var0} {var1} {var2} {var3}=((new SuplementOrderCheck()).noConfirmationOrderCheck({var0},{var1},{var2},{var3}))
[condition][]the {field} has_alpha characters in the specified range {start} to {end}=((new RangeOfValues()).numberOfAlphaInSpecRange((xcb.xpath({field})).stringValue(),{start},{end}))
[condition][]it is not true that_the {pos} to {pos} of the {field_1} is equal to {pos} to {pos} of the {field_2}=(!((new Position()).twoPositionRangeValueofTagEqualToValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field_1})).stringValue(),{pos},{pos},(xcb.xpath({field_2})).stringValue())))
[condition][]it is not true that_the {field} contains atleast one non space character in the range {start} to {end}=(!((new SpaceCheck()).checkAtleastOneNonSpaceInRange((xcb.xpath({field})).stringValue(),{start},{end})))
[condition][]it is not true that_the interval between {field_date1} and {field_date2} is equal to {days}=(!((new DateCheck()).intervalBetweenTwoDateIsEqualtoDays((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue(),{days})))
[condition][]it is not true that_anyOccurenceOf{section}{tag} equals {comma_seperated_values}=(!(virtualfieldEqualsValues({section},{tag},{comma_seperated_values})))
[condition][]it is not true that_the value of {field} not equals the occurences of{section}=(!(virtualsaliValueOfFieldNotEqualsOccurenceOfOtherSection1((xcb.xpath({field})).stringValue(),{section})))
[condition][]it is not true that_the {field} is greater than {value}=(!((new Equals()).isGreaterThan((xcb.xpath({field})).stringValue(),{value})))
[condition][]Request PON{pon} VER{ver} CCNA{ccna} ICSC{icsc} exists in DB=((new SuplementOrderCheck()).checkRequestExistsInDatabase({pon},{ver},{ccna},{icsc}))
[condition][]tagValue{var0}=((new Occurence()).tagValue({var0}))
[condition][]the {field} from positions {pos1} to {pos2} is not populated and not spaces=((new Populated()).rangeOfPositionIsNotPopulatedAndNotSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2}))
[condition][]the {field} has_segment with specified {segnum} of the specified {length} to support virgule or period=((new LengthCheck()).virguleandPeriodSegmentNumberLengthEqualTo((xcb.xpath({field})).stringValue(),{segnum},{length}))
[condition][]the{section} {field} is not unique in all the occurences with code {code}=((new Occurence()).isUnique({section},(xcb.xpath({field})).stringValue(),{code}))
[condition][]isRequired{var0}=((new Required()).isRequired({var0}))
[condition][]Is the {field} of the specified {segnum} according to the format {format}=((new DateFormatCheck()).isSpecifiedSegmentInValidFormat((xcb.xpath({field})).stringValue(),{segnum},{format}))
[condition][]it is not true that_the {field_with_xpath} occurance is atleast {number_of_times}=(!((new Occurence()).atleastOccurenceOf((xcb.xpath({field_with_xpath})).stringValue(),{number_of_times})))
[condition][]it is not true that_qtyCheckForCktact{var0} {var1} {var2}=(!((new Occurence()).qtyCheckForCktact({var0},{var1},{var2})))
[condition][]it is not true that_the multiple field{field} has_length greater than{value} in any occurence=(!((new Occurence()).lengthCheckForMultipleOccuringTag((xcb.xpath({field})).stringValue(),{value})))
[condition][]Check for reqtyp{field} pon{field}ver{ver}ccna{ccna}icsc{icsc}=((new SuplementOrderCheck()).reqtypFieldCheck((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{ver},{ccna},{icsc}))
[condition][]it is not true that_set the activity of to {var0}=(!((new ReqTypeAct()).setActivity({var0})))
[condition][]it is not true that_confirmationOrderCheck{var0} {var1} {var2} {var3}=(!((new SuplementOrderCheck()).confirmationOrderCheck({var0},{var1},{var2},{var3})))
[condition][]the {pos} and {pos} position_of the {field} is equal to {pos} and {pos} position=((new Position()).twoPositionValueofTagEqualToValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos}))
[condition][]it is not true that_segmentValueEquals{var0} {var1} {var2}=(!((new Equals()).segmentValueEquals({var0},{var1},{var2})))
[condition][]it is not true that_checkResponseIcscTagExistInRequestIcsc{var0} {var1} {var2} {var3}=(!((new SuplementOrderCheck()).checkResponse_IcscTagExistInRequestIcsc({var0},{var1},{var2},{var3})))
[condition][]it is not true that_anyOccurenceOfSaliTagEqualsValue{var0} {var1} {var2} {var3} {var4}=(!((new Occurence()).anyOccurenceOfSaliTagEqualsValue({var0},{var1},{var2},{var3},{var4})))
[condition][]it is not true that_the ccna {field_value} has_the license for the table {NC_NCI_ICSC_CLLI}=(!((new ASOGTABLE()).checkCcnaLicenseForTable((xcb.xpath({field_value})).stringValue(),{NC_NCI_ICSC_CLLI})))
[condition][]it is not true that (!((new SuplementOrderCheck()).checkTagValueInRequestforResponse()))=(!((new SuplementOrderCheck()).checkTagValueInRequestforResponse()))
[condition][]it is not true that_the {field} is AlphaNumeric with only space as special character=(!((new DatatypeCheck()).checkAlphaNumericWithSpaceAsSpecialCharacter((xcb.xpath({field})).stringValue())))
[condition][]the {field} from {pos1} to {pos2} of the segment{segnum} has_the comma seperated values{values} to support virgule or period as delimiter=((new LengthCheck()).virguleandPeriodPosToPosOfSegmentNotEquals((xcb.xpath({field})).stringValue(),{pos1},{pos2},{segnum},{values}))
[condition][]it is not true that_the {field_date1} is less than or equal to {field_date2}=(!((new DateCheck()).isLessThanOrEqualTo((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue())))
[condition][]it is not true that_CHECK FIRMORDER request{field} pon{field} ver{field} ccna{field} icsc{field}=(!((new SuplementOrderCheck()).firmOrderToServiceRequestCheck((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue())))
[condition][]Is the {field_Date1} not equal to {comparison_Date} in the format {CCYYMMDD}=((new DateFormatCheck()).isFieldNotEqualToComparisonDateInspecifiedFormat((xcb.xpath({field_Date1})).stringValue(),{comparison_Date},{CCYYMMDD}))
[condition][]it is not true that_the {field} is not populated=(!((new Populated()).isNotPopulated((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} has_specified segment {segnum} which has_the specified alpha {specAlpha}=(!((new DatatypeCheck()).segmentNotEqualToSpecifiedAlpha((xcb.xpath({field})).stringValue(),{segnum},{specAlpha})))
[condition][]it is not true that_the_length_of {field} is between {min} and {max} values=(!((new LengthCheck()).checkMinMaxLength((xcb.xpath({field})).stringValue(),{min},{max})))
[condition][]it is not true that_virtualoccurenceofuactNCI{vector} {list}{ncivalue}{errorcode}=(!(virtualoccurenceofuactNCI({vector},{list},{ncivalue},{errorcode})))
[condition][]it is not true that_the {segnum} segment of the {field_value} is present in the LOCATION Table=(!(virtualSegmentFetchAbbreviationLOCATIONTable({segnum},(xcb.xpath({field_value})).stringValue())))
[condition][]it is not true that_the {field} contains invalid values or with valid values {comma_separated_values} without spaces between them or repeated=(!((new Contains()).containsInvalidOrValidWithoutSpaceOrRepeated((xcb.xpath({field})).stringValue(),{comma_separated_values})))
[condition][]it is not true that_the minimum length of {field} is {value}=(!((new LengthCheck()).checkMinimumLength((xcb.xpath({field})).stringValue(),{value})))
[condition][]the {pos} position_of {field} is not equal to {value}=(virtualPositionOftagValueNotEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value}))
[condition][]the field {field} is numeric with the last character as the {char}=((new DatatypeCheck()).numericWithLastCharacter((xcb.xpath({field})).stringValue(),{char}))
[condition][]the {field} is compared with the specified {segnum} at the positions {pos1} to {pos2} with the specified {value}=((new Position()).compareSpecifiedSegmentWithCharPositionInValue((xcb.xpath({field})).stringValue(),{segnum},{pos1},{pos2},{value}))
[condition][]it is not true that_virtualoccurenceofVACTandUACT3CEVLAN{var0} {var1}=(!(virtualoccurenceofVACTandUACT3CEVLAN({var0},{var1})))
[condition][]the interface name does not exist=((new SuplementOrderCheck()).checkInterfaceId())
[condition][]it is not true that_the CCNA has_license for CLLI Table=(!((new SvcType()).getCLLILicense()))
[condition][]it is not true that_timeFormatWithRange{var0} {var1} {var2}=(!((new TimeFormatCheck()).timeFormatWithRange({var0},{var1},{var2})))
[condition][]the occurance of {field_with_xpath} is equal to {number}=((new Occurence()).noOfOccurenceEqualTo((xcb.xpath({field_with_xpath})).stringValue(),{number}))
[condition][]the {field} has_both uppercase and lowercase characters for commaseperated vaules=((new CapitalLetterCheck()).isUpperAndLowerCaseForCSV((xcb.xpath({field})).stringValue()))
[condition][]the {pos} and {pos} position_of the {field} is lesser than {pos} and {pos} position=((new Position()).twoPositionValueofTagIsLessThanTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos}))
[condition][]it is not true that_the {field} does not contain {CommaSeparatedValues}=(!((new Contains()).doesNotContains((xcb.xpath({field})).stringValue(),{CommaSeparatedValues})))
[condition][]it is not true that_Is the {field_Date1} not equal to {comparison_Date} in the format {CCYYMMDD}=(!((new DateFormatCheck()).isFieldNotEqualToComparisonDateInspecifiedFormat((xcb.xpath({field_Date1})).stringValue(),{comparison_Date},{CCYYMMDD})))
[condition][]the position {pos} of {field} is not_equal_to_values {comma_seperated_values}=((new Position()).positionOftagValueNotEqualToValues({pos},(xcb.xpath({field})).stringValue(),{comma_seperated_values}))
[condition][]it is not true that_the {pos} position_of {field} is equal to {value}=(!((new Position()).positionOftagValueEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value})))
[condition][]setICSCNCNCICompatibilityLicense {var0}=((new SvcType()).setICSCNCNCICompatibilityLicense({var0}))
[condition][]it is not true that_any occurrence of servpref {section}{sub_sect} populated=(!(virtualAnyOccurenceOfServPrefPopulated({section},{sub_sect})))
[condition][]set the activity of to {var0}=((new ReqTypeAct()).setActivity({var0}))
[condition][]the {field} has_a valid value {value}=((new isValidValue()).isValidValue((xcb.xpath({field})).stringValue(),{value}))
[condition][]the interval duration is blank for the {ccna} {nc} and {icsc}=((new IntervalDurationMatcher()).isIntervalExisting({ccna},{nc},{icsc}))
[condition][]the substring upto colon of the {field} equals {values}=((new SvcType()).compareSvcType((xcb.xpath({field})).stringValue(),{values}))
[condition][]the {field} has_not a valid value{comma_seperated_values}=((new isValidValue()).isNotValidValue((xcb.xpath({field})).stringValue(),{comma_seperated_values}))
[condition][]the {pos} and {pos} position_of the {field} is greater than {pos} and {pos} position=((new Position()).twoPositionValueofTagIsGreaterThanTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos}))
[condition][]it is not true that_the {field} has_the specified segment with number {segnum} whose length is less than specified {length}=(!((new LengthCheck()).segmentNumberLengthLessThan((xcb.xpath({field})).stringValue(),{segnum},{length})))
[condition][]it is not true that_setIcscCLLILicense {var0}=(!((new SvcType()).setIcscCLLILicense({var0})))
[condition][]checkForLowerCaseLettersAfterNumbers{var0}=((new CapitalLetterCheck()).checkForLowerCaseLettersAfterNumbers({var0}))
[condition][]it is not true that_is dedicated recieve customer=(!((new SuplementOrderCheck()).checkDedicatedRecieveCustomer()))
[condition][]the {field} is Alpha=((new DatatypeCheck()).checkAlpha((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the field {field} is numeric with the last character as the {char}=(!((new DatatypeCheck()).numericWithLastCharacter((xcb.xpath({field})).stringValue(),{char})))
[condition][]it is not true that_the position_of Special Character is {pos} in {field}=(!((new DatatypeCheck()).checkPositionSP({pos},(xcb.xpath({field})).stringValue())))
[condition][]the {field_date1} is less than {field_date2}=((new DateCheck()).isLessThan((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue()))
[condition][]the {field} is populated with {number_of_segment} segments=((new LengthCheck()).numberOfSegments((xcb.xpath({field})).stringValue(),{number_of_segment}))
[condition][]ccnaMultiEcIcscCheck{var0} {var1} {var2}=((new SuplementOrderCheck()).ccnaMultiEcIcscCheck({var0},{var1},{var2}))
[condition][]it is not true that_the_section {field} is not populated=(!((new Populated()).isSectionNotPopulated((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} has_telephone number format as {tn_format}=(!((new TNFormat()).tnFormatIs((xcb.xpath({field})).stringValue(),{tn_format})))
[condition][]the maximum length of {field} is {value}=((new LengthCheck()).checkMaximumlength((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the {field} has {N} number of segments=(!((new LengthCheck()).fieldHasNumberOfSegments((xcb.xpath({field})).stringValue(),{N})))
[condition][]the {field} is not populated=((new Populated()).isNotPopulated((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the message type for the valid interface equals {values}=(!((new SuplementOrderCheck()).checkMessageType({values})))
[condition][]it is not true that_checkAnyPositionsInRangeContainsValues{var0} {var1} {var2} {var3}=(!((new Position()).checkAnyPositionsInRangeContainsValues({var0},{var1},{var2},{var3})))
[condition][]it is not true that_the field value {field_value} matches the pattern {pattern}=(!((new SpecialFormat()).isPatternMatches((xcb.xpath({field_value})).stringValue(),{pattern})))
[condition][]if {pos1} and {pos2} not in foramt {chhp} for {fdt}=((new DateFormatCheck()).time_format_chkforFDT({pos1},{pos2},{chhp},{fdt}))
[condition][]the field {field_name} of {parent_name} with value {field_value} differs from previous version tag value for the pon {PON} version {VER} ccna {CCNA} and icsc{ICSC} and compare with {val1}{val2}=((new SuplementOrderCheck()).CHKVAR_Access((xcb.xpath({field_name})).stringValue(),{parent_name},(xcb.xpath({field_value})).stringValue(),{PON},{VER},{CCNA},{ICSC},{val1},{val2}))
[condition][]lrefListFieldIsNotPopulatedAssoTagIsPopulatedandCorrespondingTagEqualsVlaue{var0} {var1} {var2} {var3} {var4} {var5} {var6}=((new Occurence()).lrefListFieldIsNotPopulatedAssoTagIsPopulatedandCorrespondingTagEqualsVlaue({var0},{var1},{var2},{var3},{var4},{var5},{var6}))
[condition][]it is not true that_the {field} is Required for {comma_seperated_values}=(!((new Required()).requiredForValues((xcb.xpath({field})).stringValue(),{comma_seperated_values})))
[condition][]it is not true that_eachCharacterPreceededOrFollowedByNumeric{var0} {var1}=(!((new Contains()).eachCharacterPreceededOrFollowedByNumeric({var0},{var1})))
[condition][]it is not true that_the {field} has_the segment with specified {segnum} whose length is greater than specified {length} to support virgule or period=(!((new LengthCheck()).virguleandPeriodSegmentNumberLengthGreaterThan((xcb.xpath({field})).stringValue(),{segnum},{length})))
[condition][]valueOfFieldIsOneGreaterThanOccurenceOfAnotherField{var0} {var1}=((new Occurence()).valueOfFieldIsOneGreaterThanOccurenceOfAnotherField({var0},{var1}))
[condition][]the {field} has_specified {segmentNumber} field not equal to alpha=((new DatatypeCheck()).segmentNotEqualToAlpha((xcb.xpath({field})).stringValue(),{segmentNumber}))
[condition][]it is not true that_checkCapsInField2ForPosInField1{var0} {var1} {var2}=(!((new CapitalLetterCheck()).checkCapsInField2ForPosInField1({var0},{var1},{var2})))
[condition][]it is not true that_cktActCheckWithPrevVer{var0} {var1} {var2} {var3} {var4} {var5} {var6}=(!((new SuplementOrderCheck()).cktActCheckWithPrevVer({var0},{var1},{var2},{var3},{var4},{var5},{var6})))
[condition][]the difference between {field_date1} and {field_date2} is greater than specified {field_months}=((new DateCheck()).isRangeGreaterThanSpecifiedMonths((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue(),(xcb.xpath({field_months})).stringValue()))
[condition][]the difference between {field_date1} and {field_date2} is equal to one year=((new DateCheck()).isRangeEqualToOneYear((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue()))
[condition][]it is not true that_the CCNA has_license for ICSC Table=(!((new SvcType()).getICSCLicense()))
[condition][]duplicate order pon {pon} ver {ver} ccna {ccna} hdricsc {icsc} exists in DB=((new SuplementOrderCheck()).duplicateOrderCheckWithHDRICSC({pon},{ver},{ccna},{icsc}))
[condition][]spaceOrCharacterOrNumberInRange0199{var0} {var1} {var2} {var3} {var4}=((new Position()).spaceOrCharacterOrNumberInRange01_99({var0},{var1},{var2},{var3},{var4}))
[condition][]The{field}matches with{compString}having the specified characters{numChar} from last within the comparison string=((new Position()).compnoOfCharAtLastWithTagValueAsPerCompString((xcb.xpath({field})).stringValue(),{compString},{numChar}))
[condition][]the {field} contains all lowercase alpha character directly preceded by a numeric character=((new CapitalLetterCheck()).lowercaseAlphapreceededByNumeric((xcb.xpath({field})).stringValue()))
[condition][]the {field} is numeric followed by dot and is followed by numeric=((new RangeOfValues()).isNumericFollowedByDotFollowedByNumeric((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the field differs from previous version for the pon {PON} version {VER}icsc{ICSC} and ccna{CCNA} {field_name} of {parent_name} at pos{POS} with fieldvalue {field_value}=(!((new SuplementOrderCheck()).fieldDiffersFromPreviousVersionatspecpos({PON},{VER},{ICSC},{CCNA},(xcb.xpath({field_name})).stringValue(),{parent_name},{POS},(xcb.xpath({field_value})).stringValue())))
[condition][]the {field} having last {N} characters {chars} are preced by numeric=((new Equals()).lastNcharsprecededbynumeric((xcb.xpath({field})).stringValue(),{N},{chars}))
[condition][]the {field_date1} is greater than {field_date2}=((new DateCheck()).isGreaterThan((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue()))
[condition][]timeRange{var0} {var1} {var2}=((new TimeFormatCheck()).timeRange({var0},{var1},{var2}))
[condition][]it is not true that_The fieldDate is a valid date in the format mmddyy=(!((new DateCheck()).isValidDate2()))
[condition][]it is not true that_the position_ {pos} of {field} is not equal to {value}=(!((new Position()).positionOftagValueNotEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_the field {field_1} is greater than field {field_2}=(!((new Equals()).field1IsGreaterThanField2((xcb.xpath({field_1})).stringValue(),(xcb.xpath({field_2})).stringValue())))
[condition][]the ccna {field_value} has_the license for the table {NC_NCI_ICSC_CLLI}=((new ASOGTABLE()).checkCcnaLicenseForTable((xcb.xpath({field_value})).stringValue(),{NC_NCI_ICSC_CLLI}))
[condition][]SpecLrefchk{Lref} Lref{lref} spec{spec} and occurance{occurance} with errorCode {errorcode}=(virtualSpecLrefchk({Lref},{lref},{spec},{occurance},{errorcode}))
[condition][]any occurance of the {field1_with_xpath} is equal to comma seperated values{values}=((new Occurence()).anyOccurenceEqualToValues((xcb.xpath({field1_with_xpath})).stringValue(),{values}))
[condition][]it is not true that_the field {tagValue} is populated as per specified TLV format from positions 112=(!((new Position()).formatCheckForFields1_12({tagValue})))
[condition][]it is not true that_the {field} has_format as {format}=(!((new SpecialFormat()).formatIs((xcb.xpath({field})).stringValue(),{format})))
[condition][]it is not true that_the_length_of {field} is equal to {value}=(!((new LengthCheck()).checkLength((xcb.xpath({field})).stringValue(),{value})))
[condition][]the {field} is equal or less than {value}=((new Equals()).isEqualOrLessThan((xcb.xpath({field})).stringValue(),{value}))
[condition][]the {field} is Alpha without Special Characters Set {set_of_special_characters}=((new DatatypeCheck()).checkAlphaWithOutSPSet((xcb.xpath({field})).stringValue(),{set_of_special_characters}))
[condition][]it is not true that_the pos1{pos1} to pos2{pos2} of the field{field_value} not in range {start_value} to {end_value}=(!((new RangeOfValues()).checkPos1ToPos2ValueNotInRange({pos1},{pos2},(xcb.xpath({field_value})).stringValue(),{start_value},{end_value})))
[condition][]getXPathWithPosition{var0} {var1}=((new XpathLookup()).getXPathWithPosition({var0},{var1}))
[condition][]((new ReqTypeAct()).getRequestType())=((new ReqTypeAct()).getRequestType())
[condition][]is dedicated recieve customer=((new SuplementOrderCheck()).checkDedicatedRecieveCustomer())
[condition][]it is not true that_the {field} has_last character as upper which is followed by lower case character=(!((new CapitalLetterCheck()).lastCharUpperFollLower((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} has {count} comma separated values=(!((new CommaSeparatedSpace()).countCommaSeperatedValues((xcb.xpath({field})).stringValue(),{count})))
[condition][]it is not true that_the {field} has_specified {segmentNumber} field not equal to alpha=(!((new DatatypeCheck()).segmentNotEqualToAlpha((xcb.xpath({field})).stringValue(),{segmentNumber})))
[condition][]the {field} has_only one {char} special character present=((new DatatypeCheck()).checkRepeationOFSpecialCharacter((xcb.xpath({field})).stringValue(),{char}))
[condition][]anyOccurenceOfSaliTagEqualsValue{var0} {var1} {var2} {var3} {var4}=((new Occurence()).anyOccurenceOfSaliTagEqualsValue({var0},{var1},{var2},{var3},{var4}))
[condition][]it is not true that_setSvcName{var0}=(!((new SvcType()).setSvcName({var0})))
[condition][]segmentValueEquals{var0} {var1} {var2}=((new Equals()).segmentValueEquals({var0},{var1},{var2}))
[condition][]the {field} contains {num} of consecutive uppercase Alpha Characters=((new CapitalLetterCheck()).containsConsecutiveUppercaseAlphaCharacters((xcb.xpath({field})).stringValue(),{num}))
[condition][]spaceFollowedBySpace{var0}=((new Contains()).spaceFollowedBySpace({var0}))
[condition][]it is not true that_the {field} has_consecutive uppercase characters and should not be followed by space=(!((new CapitalLetterCheck()).consecUpperCaseWithNoSpaceAfter((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the interval duration is blank for the {ccna} {nc} and {icsc}=(!((new IntervalDurationMatcher()).isIntervalExisting({ccna},{nc},{icsc})))
[condition][]the {field} contains all lowercase alpha characters directly preceded by a numeric character=((new CapitalLetterCheck()).lowercaseAlphaCharactersPreceededByNumeric((xcb.xpath({field})).stringValue()))
[condition][]the CCNA has_license for NC Table=((new SvcType()).getNCLicense())
[condition][]the {field_with_xpath} is required=((new Required()).isRequired((xcb.xpath({field_with_xpath})).stringValue()))
[condition][]the ccna{ccna} and icsc{icsc} combination exists=((new SuplementOrderCheck()).checkCcnaIcscCombination({ccna},{icsc}))
[condition][]it is not true that_the {field} is Alpha with Special Characters Set {set_of_special_characters}=(!((new DatatypeCheck()).checkAlphaSPSet((xcb.xpath({field})).stringValue(),{set_of_special_characters})))
[condition][]it is not true that_the{field} has_the last character not_equal_to_values{value}=(!((new Equals()).lastCharacterOfFieldNotEqualValues((xcb.xpath({field})).stringValue(),{value})))
[condition][]the {field} not equals {value}=((new Equals()).isNotEquals((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_any one of the segment that may be delimeted by the char {delim_char} of the {field} does not contain {Alpha} Alpha character followed by maximum number {num} of numeric characters=(!((new LengthCheck()).segmentDoesNotContainsAlphaCountFollowedByNumericCount({delim_char},(xcb.xpath({field})).stringValue(),{Alpha},{num})))
[condition][]it is not true that_the ICSC has_license for NCNCICOMPATIBILITY Table=(!((new SvcType()).getIcscCLLILicense()))
[condition][]it is not true that_getXPathWithPosition{var0} {var1}=(!((new XpathLookup()).getXPathWithPosition({var0},{var1})))
[condition][]it is not true that_confirmationOrderCheck pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=(!((new SuplementOrderCheck()).confirmationOrderCheck({pon},{ver},{ccna},{icsc},{description})))
[condition][]CHECK FIRMORDER request{field} pon{field} ver{field} ccna{field} icsc{field}=((new SuplementOrderCheck()).firmOrderToServiceRequestCheck((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue()))
[condition][]it is not true that_getLatestVersion{var0} {var1}=(!((new SuplementOrderCheck()).getLatestVersion({var0},{var1})))
[condition][]the field differs from previous version for the pon {PON} version {VER}icsc{ICSC} and ccna{CCNA} {field_name} of {parent_name} at pos{POS} with fieldvalue {field_value}=((new SuplementOrderCheck()).fieldDiffersFromPreviousVersionatspecpos({PON},{VER},{ICSC},{CCNA},(xcb.xpath({field_name})).stringValue(),{parent_name},{POS},(xcb.xpath({field_value})).stringValue()))
[condition][]it is not true that_routing matrix value check when any ALL is present{section}{subsect}{field}=(!(virtualRoutingMatrixCheck1({section},{subsect},(xcb.xpath({field})).stringValue())))
[condition][]checkResponsePonDoesNotExistInRequest{var0} {var1} {var2}=((new SuplementOrderCheck()).checkResponsePonDoesNotExistInRequest({var0},{var1},{var2}))
[condition][]it is not true that_the CCNA has_license for NC Table=(!((new SvcType()).getNCLicense()))
[condition][]it is not true that_firstPositionRangeGreaterThanSecondPositionRange{var0} {var1} {var2} {var3} {var4}=(!((new Position()).firstPositionRangeGreaterThanSecondPositionRange({var0},{var1},{var2},{var3},{var4})))
[condition][]it is not true that_virtualoccurenceofVACTandUACT3{section} {errorcode}=(!(virtualoccurenceofVACTandUACT3({section},{errorcode})))
[condition][]noOfCharactersinTag{var0} {var1} {var2}=((new Contains()).NoOfCharactersinTag({var0},{var1},{var2}))
[condition][]virtualoccurenceofuactNCIRuid{vector} {list}{ncivalue}{errorcode}=(virtualoccurenceofuactNCIRuid({vector},{list},{ncivalue},{errorcode}))
[condition][]the {field} is AlphaNumeric with only space as special character=((new DatatypeCheck()).checkAlphaNumericWithSpaceAsSpecialCharacter((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} at the position {start} to {end} does not contain any Alpha Numeric characters=(!((new RangeOfValues()).noExistenceOfAlpha_NumericAtSpecRange((xcb.xpath({field})).stringValue(),{start},{end})))
[condition][]it is not true that_any of the occurance of {field_with_xpath} exists=(!((new Occurence()).anyOccurenceExists((xcb.xpath({field_with_xpath})).stringValue())))
[condition][]anyOccurenceOf{section}{tag} equals {comma_seperated_values}=(virtualfieldEqualsValues({section},{tag},{comma_seperated_values}))
[condition][]it is not true that_noOfOccurenceGreaterThanValue{var0} {var1}=(!((new Occurence()).noOfOccurenceGreaterThanValue({var0},{var1})))
[condition][]the {field} does not match with {field2} at the specified character positions {pos1} to {pos2}=((new Position()).compStringDoesntMatchTagValueAtSpecPosition((xcb.xpath({field})).stringValue(),(xcb.xpath({field2})).stringValue(),{pos1},{pos2}))
[condition][]it is not true that_the difference between {field_date1} and {field_date2} is less than one year=(!((new DateCheck()).isRangeLesserThanOneYear((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue())))
[condition][]the {field} has_specified {segmentNumber} not equal to numeric=((new DatatypeCheck()).segmentNotEqualToNumeric((xcb.xpath({field})).stringValue(),{segmentNumber}))
[condition][]it is not true that_the segment {segnum} length of the field {field_value} is in the range {min} and {max}=(!(virtualSegmentNumberLengthInRange({segnum},(xcb.xpath({field_value})).stringValue(),{min},{max})))
[condition][]it is not true that_getSaliParent of{parent} in{section} for{tag}=(!((new Occurence()).getSaliParent({parent},{section},{tag})))
[condition][]characterPreceededOrFollowedByNumeric{var0} {var1}=((new Contains()).characterPreceededOrFollowedByNumeric({var0},{var1}))
[condition][]the{section}{subsect}{field} populated and assosiated tag{tag}is not populated or corresponding section tag{corrstag}not equals to {values}=(virtualLrefListFieldPopulatedAssoTagIsNotPopulatedOrCorrespondingTagNotEqualsVlaues({section},{subsect},(xcb.xpath({field})).stringValue(),{tag},{corrstag},{values}))
[condition][]it is not true that_the {field} contains {num} of consecutive lowercase Alpha Characters=(!((new CapitalLetterCheck()).containsConsecutiveLowercaseAlphaCharacters((xcb.xpath({field})).stringValue(),{num})))
[condition][]the {field_date1} is a valid date=((new DateCheck()).isValidDate((xcb.xpath({field_date1})).stringValue()))
[condition][]it is not true that_the {field} is numeric with trailing spaces=(!((new DatatypeCheck()).checkNumericWithTrailingSPacesOnly((xcb.xpath({field})).stringValue())))
[condition][]the {field} is Numeric with Special Characters=((new DatatypeCheck()).checkNumericSP((xcb.xpath({field})).stringValue()))
[condition][]isValidDate1{var0}=((new DateCheck()).isValidDate1({var0}))
[condition][]it is not true that_the {field} is compared with the specified {segnum} at the positions {pos1} to {pos2} with the specified {value}=(!((new Position()).compareSpecifiedSegmentWithCharPositionInValue((xcb.xpath({field})).stringValue(),{segnum},{pos1},{pos2},{value})))
[condition][]it is not true that_the version {VER} is not one greater than the previous database version for the pon {PON} ccna {CCNA} and icsc {ICSC} with status {status}=(!((new SuplementOrderCheck()).verNotOneGreaterThanLatestDBVersion({VER},{PON},{CCNA},{ICSC},{status})))
[condition][]the position_of Numeric is {pos} in {field}=((new DatatypeCheck()).checkPositionNumeric({pos},(xcb.xpath({field})).stringValue()))
[condition][]the no of occurances of {field_xpath} pair have different {field_xpath} values=((new Occurence()).noOfOccurancesOfLactIOPairMustHaveDiffAliValue((xcb.xpath({field_xpath})).stringValue(),(xcb.xpath({field_xpath})).stringValue()))
[condition][]it is not true that_the {field_date1} is less than {field_date2}=(!((new DateCheck()).isLessThan((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue())))
[condition][]Number of occurence of Field {Field_Xpath} is in range from {min_value} To {max_value}=((new Occurence()).noOfOccurenceOfFieldInRange({Field_Xpath},{min_value},{max_value}))
[condition][]the {field} is populated=((new Populated()).isPopulated((xcb.xpath({field})).stringValue()))
[condition][]the sup {Sup_Field_Value} is populated with pon {Pon_Field_Value} and version {Ver_Field_Value} and ccna {Ccna_Field_Value} and icsc {Icsc_Field_Value} and qty {Qty_Field_Value} on the current order which has_decreasing QTY with respect to the previous order=((new SuplementOrderCheck()).qtyFieldCheck({Sup_Field_Value},{Pon_Field_Value},{Ver_Field_Value},{Ccna_Field_Value},{Icsc_Field_Value},{Qty_Field_Value}))
[condition][]any occurence of{field_with_xpath} is not populated=((new Occurence()).anyOccurenceOfFieldNotPopulated((xcb.xpath({field_with_xpath})).stringValue()))
[condition][]it is not true that_the {field_date1} is greater than {field_date2}=(!((new DateCheck()).isGreaterThan((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue())))
[condition][]setICSCLicense {var0}=((new SvcType()).setICSCLicense({var0}))
[condition][]the {segnum} segment of the {field_value} is present in the LOCATION Table=(virtualSegmentFetchAbbreviationLOCATIONTable({segnum},(xcb.xpath({field_value})).stringValue()))
[condition][]it is not true that_spaceFollowedBySpace{var0}=(!((new Contains()).spaceFollowedBySpace({var0})))
[condition][]it is not true that_the {field_date1} is a valid date=(!((new DateCheck()).isValidDate((xcb.xpath({field_date1})).stringValue())))
[condition][]the CCNA has_license for CLLI Table=((new SvcType()).getCLLILicense())
[condition][]it is not true that_the sup {Sup_Field_Value} is populated with pon {Pon_Field_Value} and version {Ver_Field_Value} and ccna {Ccna_Field_Value} and icsc {Icsc_Field_Value} on the current order and matching with the previous order which has_a status COMPLETED=(!((new SuplementOrderCheck()).completionOrderCheck({Sup_Field_Value},{Pon_Field_Value},{Ver_Field_Value},{Ccna_Field_Value},{Icsc_Field_Value})))
[condition][]it is not true that_any occurence of multiple {field} is populated=(!((new Occurence()).anyOccurenceOfMultipleFieldIsPopulated((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {section}{field} is not populated in all occurence=(!((new Occurence()).VirtualNoOccurenceIsPopulated({section},(xcb.xpath({field})).stringValue())))
[condition][]the {field} is Numeric=((new DatatypeCheck()).checkNumeric((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_virtualoccurenceofVACTandUACT2CEVLAN{var0} {var1}=(!(virtualoccurenceofVACTandUACT2CEVLAN({var0},{var1})))
[condition][]it is not true that_the {field} has_specified {segmentNumber} field not equal to alpha with virgule or period as delimiter=(!((new DatatypeCheck()).virguleandPeriodSegmentNotEqualToAlpha((xcb.xpath({field})).stringValue(),{segmentNumber})))
[condition][]the{section}{subsect}{field}not populated and assosiated tag{tag}is populated and corresponding section tag{corrstag}equals to {values}=(virtualLrefListFieldIsNotPopulatedAssoTagIsPopulatedandCorrespondingTagEqualsVlaue({section},{subsect},(xcb.xpath({field})).stringValue(),{tag},{corrstag},{values}))
[condition][]the {field} has {count} comma separated values=((new CommaSeparatedSpace()).countCommaSeperatedValues((xcb.xpath({field})).stringValue(),{count}))
[condition][]the interval between {field_date1} and {field_date2} is greater than {days}=((new DateCheck()).intervalBetweenTwoDateIsGreaterThanDays((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue(),{days}))
[condition][]it is not true that_the {field} from positions {pos1} to {pos2} is not populated and not spaces=(!((new Populated()).rangeOfPositionIsNotPopulatedAndNotSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2})))
[condition][]the {pos} position_Of {field} equal to {value}=((new Contains()).positionOfFieldEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the occurance of {field_with_xpath} is greaterthan {number}=(!((new Occurence()).noOfOccurenceGreaterThan((xcb.xpath({field_with_xpath})).stringValue(),{number})))
[condition][]it is not true that_the {field} has_segment with specified {segnum} of the specified {length}=(!((new LengthCheck()).segmentNumberLengthEqualTo((xcb.xpath({field})).stringValue(),{segnum},{length})))
[condition][]the order with asog version  {ver} icsc  {icsc} and {msg_time_stamp} cannot be submitted because of ASOG Upgrade=(virtualAsogCutOverOrderReject({ver},{icsc},{msg_time_stamp}))
[condition][]it is not true that_lrefListFieldIsNotPopulatedAssoTagIsPopulatedandCorrespondingTagEqualsVlaue{var0} {var1} {var2} {var3} {var4} {var5} {var6}=(!((new Occurence()).lrefListFieldIsNotPopulatedAssoTagIsPopulatedandCorrespondingTagEqualsVlaue({var0},{var1},{var2},{var3},{var4},{var5},{var6})))
[condition][]getLatestVersion{var0} {var1}=((new SuplementOrderCheck()).getLatestVersion({var0},{var1}))
[condition][]the {field_value} is present on ICSC table=((new ASOGTABLE()).fetchAbbreviationICSCTable((xcb.xpath({field_value})).stringValue()))
[condition][]it is not true that_positionOfAllFieldNotEqualToCharacter{var0} {var1} {var2}=(!((new Occurence()).positionOfAllFieldNotEqualToCharacter({var0},{var1},{var2})))
[condition][]the {field} contains atleast one non space character in the range {start} to {end}=((new SpaceCheck()).checkAtleastOneNonSpaceInRange((xcb.xpath({field})).stringValue(),{start},{end}))
[condition][]it is not true that_setSvcNameUOM {var0}=(!((new SvcType()).setSvcNameUOM({var0})))
[condition][]number of occurences{field_with_xpath} equals{value}=((new Occurence()).noOfOccurenceEqualsValue((xcb.xpath({field_with_xpath})).stringValue(),{value}))
[condition][]it is not true that_the {field} contains all lowercase alpha character directly preceded by a numeric character=(!((new CapitalLetterCheck()).lowercaseAlphapreceededByNumeric((xcb.xpath({field})).stringValue())))
[condition][]the{section}{field}is populated and assosiated tag{tag} not equals to values{values}=(virtualAnyOccurenceOfFieldPopulatedAndAssosiatedTagNotEqualsValues({section},(xcb.xpath({field})).stringValue(),{tag},{values}))
[condition][]the {field} contains numeric characters=((new Contains()).containsNumeric((xcb.xpath({field})).stringValue()))
[condition][]isCurrentDateLessThanOrEqualToDesiredDueDate{var0}=((new DateCheck()).isCurrentDateLessThanOrEqualToDesiredDueDate({var0}))
[condition][]it is not true that_virtualIntegerToString{var0}=(!(virtualIntegerToString({var0})))
[condition][]the {fieldName} in {parentSection} is less than {fieldValue} for the {pon} {ver} {ccna} {icsc}=((new SuplementOrderCheck()).isCurrentDDDLessThanPreviousVersionDDD((xcb.xpath({fieldName})).stringValue(),{parentSection},(xcb.xpath({fieldValue})).stringValue(),{pon},{ver},{ccna},{icsc}))
[condition][]isCurrentDateLessThanOrNotEqualToDesiredDueDate{var0}=((new DateCheck()).isCurrentDateLessThanOrNotEqualToDesiredDueDate({var0}))
[condition][]setSvcName{var0}=((new SvcType()).setSvcName({var0}))
[condition][]it is not true that_the interface name does not exist=(!((new SuplementOrderCheck()).checkInterfaceId()))
[condition][]the sup {Sup_Field_Value} is populated with pon {Pon_Field_Value} and version {Ver_Field_Value} and ccna {Ccna_Field_Value} and icsc {Icsc_Field_Value} on the current order and matching with the previous order which has_a status COMPLETED=((new SuplementOrderCheck()).completionOrderCheck({Sup_Field_Value},{Pon_Field_Value},{Ver_Field_Value},{Ccna_Field_Value},{Icsc_Field_Value}))
[condition][]the {field_date1} is less than or equal to {field_date2}=((new DateCheck()).isLessThanOrEqualTo((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue()))
[condition][]it is not true that_the {field} has_virgule or period as delimiter=(!((new DatatypeCheck()).fieldHasOneDelimiter((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_tag value of the request order for the pon{pon}ver{ver}ccna{ccna}icsc{icsc}section{section}tag{tag} not equals {value}=(!((new SuplementOrderCheck()).requestDoesNothaveTheTagValue({pon},{ver},{ccna},{icsc},{section},{tag},{value})))
[condition][]{field} has_atleast {occurance} occurances populated=((new Occurence()).atleastOccurenceOfTagPopulated((xcb.xpath({field})).stringValue(),{occurance}))
[condition][]the {field} has_telephone number format as {tn_format}=((new TNFormat()).tnFormatIs((xcb.xpath({field})).stringValue(),{tn_format}))
[condition][]it is not true that_SpecLrefchk{Lref} Lref{lref} spec{spec} and occurance{occurance} with errorCode {errorcode}=(!(virtualSpecLrefchk({Lref},{lref},{spec},{occurance},{errorcode})))
[condition][]it is not true that_the {field} is NotProhibited=(!((new Prohibited()).isNotProhibited((xcb.xpath({field})).stringValue())))
[condition][]it is not true that (!((new SvcType()).getSvcName()))=(!((new SvcType()).getSvcName()))
[condition][]the multiple field{field} has_length greater than{value} in any occurence=((new Occurence()).lengthCheckForMultipleOccuringTag((xcb.xpath({field})).stringValue(),{value}))
[condition][]all occurence of{section}{field} not equals{value} erroring to last occurence with{errorcode}=(virtualAllOccurenceOfFieldNotEqualsValue({section},(xcb.xpath({field})).stringValue(),{value},{errorcode}))
[condition][]eachCharacterPreceededOrFollowedByNumeric{var0} {var1}=((new Contains()).eachCharacterPreceededOrFollowedByNumeric({var0},{var1}))
[condition][]the field {field} has_pattern {pattern}=((new SpecialFormat()).patternChecking((xcb.xpath({field})).stringValue(),{pattern}))
[condition][]it is not true that_the {field_value} is present in NC table=(!((new ASOGTABLE()).fetchAbbreviationNCTable((xcb.xpath({field_value})).stringValue())))
[condition][]the pon {PON} ccna {CCNA}  icsc{ICSC} and ver{ver} combination has_the response with description {DESCRIPTION} and the previous version SUP1 order with status {CURRENTSTATUS} for the xml {xmlins}=(virtual_prevOrderSUP1CheckWithRespAccept({PON},{CCNA},{ICSC},{ver},{DESCRIPTION},{CURRENTSTATUS},{xmlins}))
[condition][]it is not true that_the {pos1} to {pos2} of the {field} is present in LOCATION Table=(!((new ASOGTABLE()).posToPosfetchAbbreviationLOCATIONTable({pos1},{pos2},(xcb.xpath({field})).stringValue())))
[condition][]getvalue{var0}=((new Occurence()).getvalue({var0}))
[condition][]it is not true that_The{field}matches with{compString}having the specified characters{numChar} from last within the comparison string=(!((new Position()).compnoOfCharAtLastWithTagValueAsPerCompString((xcb.xpath({field})).stringValue(),{compString},{numChar})))
[condition][]the field {tagValue} is populated as per specified TLV format from positions 112=((new Position()).formatCheckForFields1_12({tagValue}))
[condition][]virtualuactValueCheckWithPreviousVersion {section} {sup} {pon} {ver} {ccna} {icsc} {uact} {value} {uref} with {code}=((new Occurence()).VirtualUactValueCheckWithPreviousVersion({section},{sup},{pon},{ver},{ccna},{icsc},{uact},{value},{uref},{code}))
[condition][]it is not true that_the substring upto colon of the {field} equals {values}=(!((new SvcType()).compareSvcType((xcb.xpath({field})).stringValue(),{values})))
[condition][]the_section {field} is not populated=((new Populated()).isSectionNotPopulated((xcb.xpath({field})).stringValue()))
[condition][]the {field} has_space as a special character=((new SpaceCheck()).spaceAsSpecialCharacter((xcb.xpath({field})).stringValue()))
[condition][]the interval between {field_date1} and {field_date2} is equal to {days}=((new DateCheck()).intervalBetweenTwoDateIsEqualtoDays((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue(),{days}))
[condition][]it is not true that_the {pos} and {pos} position_of the {field} is greater than or equal to {pos} and {pos} position=(!((new Position()).twoPositionValueofTagIsGreaterThanOrEqualToTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos})))
[condition][]the {field_value} is in HHMMAHHMMP format and the difference is equal to or greater than {value} hours=((new TimeFormatCheck()).appointmentTimeFormatRange((xcb.xpath({field_value})).stringValue(),{value}))
[condition][]the {field} has_both uppercase and lowercase characters=((new CapitalLetterCheck()).isUpperAndLowerCase((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field_date1} is todays date=(!((new DateCheck()).isToday((xcb.xpath({field_date1})).stringValue())))
[condition][]the interval between {field_date1} and {field_date2} is not equal to {days}=((new DateCheck()).intervalBetweenTwoDateIsNotEqualtoDays((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue(),{days}))
[condition][]it is not true that_any occurance{field_with_xpath}fieldisPopulated=(!((new Occurence()).anyOccurenceOfFieldPopulated((xcb.xpath({field_with_xpath})).stringValue())))
[condition][]spaceFollowedBySpaceFollowedByChar{var0}=((new SpaceCheck()).spaceFollowedBySpaceFollowedByChar({var0}))
[condition][]the field {field} with segment {segnum} is populated=((new Populated()).segmentIsPopulated((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]the CCNA has_license for ICSC Table=((new SvcType()).getICSCLicense())
[condition][]it is not true that_the interval duration is blank for the {nc}=(!((new IntervalDurationMatcher()).isIntervalExisting({nc})))
[condition][]it is not true that_the {field} not equal to specified {value} of the specified {segnum}=(!((new Equals()).segmentValueNotEqualToEnteredValue((xcb.xpath({field})).stringValue(),{value},{segnum})))
[condition][]the interval between {field_date1} and {field_date2} is less than or equal to {days}=((new DateCheck()).intervalBetweenTwoDateIsLessThanOrEqualtoDays((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue(),{days}))
[condition][]AnyOccoffield1withsection{multiecoec} field1 {OECICSC}equals field2{field2} with values {value1} and {value2} with errorCode {errorcode}=(virtualAnyOccoffield1equalsvaluewherefield2notequalsvalue({multiecoec},{OECICSC},(xcb.xpath({field2})).stringValue(),{value1},{value2},{errorcode}))
[condition][]it is not true that_routing matrix value check when first column is ALL{section}{subsect}{field}=(!(virtualRoutingMatrixCheck2({section},{subsect},(xcb.xpath({field})).stringValue())))
[condition][]all occurences of {section} of field {field} equals the value{value} with errorcode {errorcode}=(virtualAllOccurenceOfFieldEqualsValue({section},(xcb.xpath({field})).stringValue(),{value},{errorcode}))
[condition][]the {field} has {comma_seperated_values}=((new ValidValueCheck()).validCommaSeperatedValue((xcb.xpath({field})).stringValue(),{comma_seperated_values}))
[condition][]setNCLicense {var0}=((new SvcType()).setNCLicense({var0}))
[condition][]the {field} has_words seperated by a comma=((new DatatypeCheck()).commaPresenceForMoreThanOneWord((xcb.xpath({field})).stringValue()))
[condition][]virguleFollowedByVirgule{var0}=((new Contains()).virguleFollowedByVirgule({var0}))
[condition][]the position_ {pos} of {field} is not equal to {value}=((new Position()).positionOftagValueNotEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_setCLLILicense{var0}=(!((new SvcType()).setCLLILicense({var0})))
[condition][]it is not true that_asogCutOverOrderReject{ver} {icsc}{msg_time_stamp}=(!((new AsogGuidelineVersion()).asogCutOverOrderReject({ver},{icsc},{msg_time_stamp})))
[condition][]any occurrence of servpref {section}{sub_sect} populated=(virtualAnyOccurenceOfServPrefPopulated({section},{sub_sect}))
[condition][]the {field} has_the specified {value} in the range {start} to {end}=((new RangeOfValues()).compareSpecStringInRange((xcb.xpath({field})).stringValue(),{value},{start},{end}))
[condition][]it is not true that_the each position_from {pos1} to {pos2} of {field} is not_equal_to_values{comma_seperated_values}=(!((new Position()).checkEachPositionsInRangeNotEqualToValues({pos1},{pos2},(xcb.xpath({field})).stringValue(),{comma_seperated_values})))
[condition][]it is not true that_the CCNA has_license for NCI Table=(!((new SvcType()).getNCILicense()))
[condition][]virtualisIntervalDurationMatchingForNc{var0} {var1}=(virtualisIntervalDurationMatchingForNc({var0},{var1}))
[condition][]it is not true that_the {pos} position_of {field1} is equal to {pos} position_of {field2}=(!((new Position()).positionOfOneFieldIsEqualToPositionOfAnother({pos},(xcb.xpath({field1})).stringValue(),{pos},(xcb.xpath({field2})).stringValue())))
[condition][]it is not true that_virtualoccurenceofVACTandUACTCEVLAN{var0} {var1}=(!(virtualoccurenceofVACTandUACTCEVLAN({var0},{var1})))
[condition][]any occurence of multiple {field} is populated=((new Occurence()).anyOccurenceOfMultipleFieldIsPopulated((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_virtualoccOfOTCnEVMPIDwithinsameUNIMAPPING{section} {errorcode}=(!(virtualoccOfOTCnEVMPIDwithinsameUNIMAPPING({section},{errorcode})))
[condition][]lrefTagCheck{var0} {var1} {var2} {var3}=((new SuplementOrderCheck()).lrefTagCheck({var0},{var1},{var2},{var3}))
[condition][]it is not true that_the {field} is Numeric without Special Characters Set {set_of_special_characters}=(!((new DatatypeCheck()).checkNumericWithOutSPSet((xcb.xpath({field})).stringValue(),{set_of_special_characters})))
[condition][]the {field} is Alpha with Special Characters Set {set_of_special_characters}=((new DatatypeCheck()).checkAlphaSPSet((xcb.xpath({field})).stringValue(),{set_of_special_characters}))
[condition][]it is not true that_the field differs from previous version tag value for the pon {PON} version {VER}icsc{ICSC} and ccna{CCNA} {field_name} of {parent_name} at pos{POS} with field {field_value}=(!((new SuplementOrderCheck()).tagValueDiffersInPreviousVersionatspecpos({PON},{VER},{ICSC},{CCNA},(xcb.xpath({field_name})).stringValue(),{parent_name},{POS},(xcb.xpath({field_value})).stringValue())))
[condition][]it is not true that_valueOfFieldIsEqualToccurenceOfAnotherField{var0} {var1}=(!((new Occurence()).valueOfFieldIsEqualToccurenceOfAnotherField({var0},{var1})))
[condition][]positionOfStringInSpecifiedRange{var0} {var1} {var2} {var3}=((new RangeOfValues()).PositionOfStringInSpecifiedRange({var0},{var1},{var2},{var3}))
[condition][]it is not true that_the {field} from {pos1} to {pos2} of the segment{segnum} are not alpha characters to supportvirgule or period as delimiter=(!((new LengthCheck()).virguleandPeriodPosToPosOfSegmentAreNotAlpha((xcb.xpath({field})).stringValue(),{pos1},{pos2},{segnum})))
[condition][]it is not true that_occurenceOfFieldIsGreaterThanSpecifiedNumberWithGivenValue{var0} {var1} {var2}=(!((new Occurence()).occurenceOfFieldIsGreaterThanSpecifiedNumberWithGivenValue({var0},{var1},{var2})))
[condition][]the {field} is AlphaNumeric without following Special Character set {set_of_special_characters}=((new DatatypeCheck()).checkAlphaNumericWithOutSPSet((xcb.xpath({field})).stringValue(),{set_of_special_characters}))
[condition][]the {pos} and {pos} position_of the {field} is not equal to {pos} and {pos} position=((new Position()).twoPositionValueofTagNotEqualToValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos}))
[condition][]virtualoccOfF1POPnF2NOTPOPwithinsameUNIMAPPING{section} {errorcode} {field1} {field2} {field3}=(virtualoccOfF1POPnF2NOTPOPwithinsameUNIMAPPING({section},{errorcode},(xcb.xpath({field1})).stringValue(),(xcb.xpath({field2})).stringValue(),(xcb.xpath({field3})).stringValue()))
[condition][]it is not true that_the {pos} and {pos} position_of the {field} is lesser than {pos} and {pos} position=(!((new Position()).twoPositionValueofTagIsLessThanTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos})))
[condition][]the {field} is NotProhibited=((new Prohibited()).isNotProhibited((xcb.xpath({field})).stringValue()))
[condition][]the {field} does not match with {compstring} having the specified Characters {numChar} from last within the comparison string=((new Position()).CompStringDoesntMatchWithSpecifiedChars((xcb.xpath({field})).stringValue(),{compstring},{numChar}))
[condition][]it is not true that_the {field} is Prohibited for {comma_seperated_values}=(!((new Prohibited()).prohibitedForValues((xcb.xpath({field})).stringValue(),{comma_seperated_values})))
[condition][]it is not true that_the {field_value} is present in the LOCATION table=(!((new ASOGTABLE()).fetchAbbreviationLOCATIONTable((xcb.xpath({field_value})).stringValue())))
[condition][]the maximum length of the trimmed field {field_value} is {length}=(virtualCheckMaximumLengthOfTrimmedTag((xcb.xpath({field_value})).stringValue(),{length}))
[condition][]the difference between {field_date1} and {field_date2} is less than one year=((new DateCheck()).isRangeLesserThanOneYear((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue()))
[condition][]the {field} has_virgule or period as delimiter=((new DatatypeCheck()).fieldHasOneDelimiter((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_any occurence of {section}{field} is not populated with  {errorcode}=(!((new Occurence()).VirtualAnyOccurenceIsNotPopulated({section},(xcb.xpath({field})).stringValue(),{errorcode})))
[condition][]it is not true that_the {field} has_all uppercase characters=(!((new CapitalLetterCheck()).isAllUpperCase((xcb.xpath({field})).stringValue())))
[condition][]the_section {section} for the field {feild} with {compvalue} and {innercompvalue} for field {innerfeild} and {errorcode}=(virtualoccurenceofSvlanMapping({section},{feild},{compvalue},{innercompvalue},{innerfeild},{errorcode}))
[condition][]the {field_date1} is a Weekend=((new DateCheck()).isHoliday((xcb.xpath({field_date1})).stringValue()))
[condition][]the {field} is according to the specified {format}=((new SpecialFormat()).isFieldAccordingToFormat((xcb.xpath({field})).stringValue(),{format}))
[condition][]it is not true that_section{section} tag{tag} not populated=(!(virtualNotPopulated({section},{tag})))
[condition][]segmentEqualToAlphaNumericWithSPChar{var0} {var1} {var2}=((new DatatypeCheck()).segmentEqualToAlphaNumericWithSPChar({var0},{var1},{var2}))
[condition][]it is not true that_checkAlphaNumericWithASingleSpecialCharacter{var0} {var1}=(!((new DatatypeCheck()).checkAlphaNumericWithASingleSpecialCharacter({var0},{var1})))
[condition][]it is not true that_presenceOfSpaceOtherThanSpecifiedPosition{var0} {var1}=(!((new Position()).presenceOfSpaceOtherThanSpecifiedPosition({var0},{var1})))
[condition][]it is not true that_the {field} with segment{segnum} is populated=(!((new DatatypeCheck()).segmentPopulated((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]the {field} contains {num} of spaces before Alpha Characters=((new CapitalLetterCheck()).containsConsecutiveSpacesBeforeAlphaCharacters((xcb.xpath({field})).stringValue(),{num}))
[condition][]getSaliParent of{parent} in{section} for{tag}=((new Occurence()).getSaliParent({parent},{section},{tag}))
[condition][]the {pos} and {pos} position_of the {field} is lesser than or equal to {pos} and {pos} position=((new Position()).twoPositionValueofTagIsLessThanOrEqualToTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos}))
[condition][]the {field_with_xpath} is not prohibited=((new Prohibited()).isNotProhibited((xcb.xpath({field_with_xpath})).stringValue()))
[condition][]it is not true that_the {field_with_xpath} is required=(!((new Required()).isRequired((xcb.xpath({field_with_xpath})).stringValue())))
[condition][]it is not true that_duplicate order pon {pon} ver {ver} ccna {ccna} hdricsc {icsc} exists in DB=(!((new SuplementOrderCheck()).duplicateOrderCheckWithHDRICSC({pon},{ver},{ccna},{icsc})))
[condition][]the_section {section} {field} is populated in any occurence with  {errorcode}=(virtualFieldIsPopulated({section},(xcb.xpath({field})).stringValue(),{errorcode}))
[condition][]the_section EVC {section} with subsection {subsect} for the field {field} is not conecutively assigned starting with {value} then errorcode {errorcode}=(virtuallrefIsNotConecutivelyAssignedStratingWIthValue({section},{subsect},(xcb.xpath({field})).stringValue(),{value},{errorcode}))
[condition][]The {field} contains whitespaces or numbers in range or zeros from second position_to end=((new Position()).charAtPositionCheck((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_any occurance of the {field_with_xpath} is not equal to {values} values=(!((new Occurence()).anyOccurenceNotEqualToValues((xcb.xpath({field_with_xpath})).stringValue(),{values})))
[condition][]virtualSegmentCount{var0}=(virtualSegmentCount({var0}))
[condition][]it is not true that_the {field_date1} is greater than or equal to {field_date2}=(!((new DateCheck()).isGreaterThanOrEqualTo((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue())))
[condition][]it is not true that_segmentValueEqualToValues{var0} {var1} {var2}=(!((new Equals()).segmentValueEqualToValues({var0},{var1},{var2})))
[condition][]it is not true that_the pon{field} ver{field} section{section} tag{tag} at {pos} is populated in Request against Response=(!((new SuplementOrderCheck()).checkResponseTagExistInRequestatPosition((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{section},{tag},{pos})))
[condition][]the {field} with segment {segnum} is not populated=((new Populated()).segmentIsNotPopulated((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]the{field} has_the last character not_equal_to_values{value}=((new Equals()).lastCharacterOfFieldNotEqualValues((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the {field} is Alpha without Special Characters Set {set_of_special_characters}=(!((new DatatypeCheck()).checkAlphaWithOutSPSet((xcb.xpath({field})).stringValue(),{set_of_special_characters})))
[condition][]it is not true that_number of occurences{field_with_xpath} equals{value}=(!((new Occurence()).noOfOccurenceEqualsValue((xcb.xpath({field_with_xpath})).stringValue(),{value})))
[condition][]the {field_value} not equal to specified values {CommaSeparatedValues} of the specified {segnum}=((new Equals()).segmentValueNotEqualToValues((xcb.xpath({field_value})).stringValue(),{CommaSeparatedValues},{segnum}))
[condition][]it is not true that_vitualsvlanthirdOccurenceProhibit{vector} {errorcode}=(!((new Occurence()).vitualsvlanthirdOccurenceProhibit({vector},{errorcode})))
[condition][]any occurance{field_with_xpath}fieldisPopulated=((new Occurence()).anyOccurenceOfFieldPopulated((xcb.xpath({field_with_xpath})).stringValue()))
[condition][]checkCcnaIcscCombinationInSECONDARYSOURCETARGETINFO{xmlInstance} {ccna} {icsc}=((new SuplementOrderCheck()).checkCcnaIcscCombinationInSECONDARYSOURCETARGETINFO({xmlInstance},{ccna},{icsc}))
[condition][]it is not true that_any occurence of field{section}{field} is not populated and assosiated tag{tag} equals {values}and corresponding tag{tag} equals {values}=(!(virtualAnyOccurenceOfFieldNotPopulatedAndAssosiatedTagEqualsValuesAndCorrespondingTagEqualsValues({section},(xcb.xpath({field})).stringValue(),{tag},{values},{tag},{values})))
[condition][]the_section{section} parent{parent} tag {tag} has_value{value} in any occurence=(virtualAnyOccurenceOfSaliTagEqualsValue({section},{parent},{tag},{value}))
[condition][]it is not true that_the occurance of {field_with_xpath} is less than {number}=(!((new Occurence()).noOfOccurenceLessThan((xcb.xpath({field_with_xpath})).stringValue(),{number})))
[condition][]it is not true that_the {field} has_specified range {start} to {end}=(!((new RangeOfValues()).rangeCheckNN_NN((xcb.xpath({field})).stringValue(),{start},{end})))
[condition][]the {field} has_specified segment {segnum} which has_the specified alpha {specAlpha}=((new DatatypeCheck()).segmentNotEqualToSpecifiedAlpha((xcb.xpath({field})).stringValue(),{segnum},{specAlpha}))
[condition][]virguleandPeriodSegmentValueEqualToValues{var0} {var1} {var2}=((new Equals()).virguleandPeriodSegmentValueEqualToValues({var0},{var1},{var2}))
[condition][]it is not true that_the {field} is AlphaNumeric with following Special Character set {set_of_special_characters}=(!((new DatatypeCheck()).checkAlphaNumericSPSet((xcb.xpath({field})).stringValue(),{set_of_special_characters})))
[condition][]it is not true that_setNCNCICompatibilityLicense  {var0} =(!((new SvcType()).setNCNCICompatibilityLicense({var0})))
[condition][]it is not true that_the {field_with_xpath} is not required=(!((new Required()).isNotRequired((xcb.xpath({field_with_xpath})).stringValue())))
[condition][]it is not true that_the {field} not equals {value}=(!((new Equals()).isNotEquals((xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_the {pos} position_of {field} is not_equal_to_values {comma_seperated_values}=(!(virtualPositionOftagValueNotEqualToValues({pos},(xcb.xpath({field})).stringValue(),{comma_seperated_values})))
[condition][]fieldPositionInRange{var0} {var1} {var2} {var3}=((new RangeOfValues()).fieldPositionInRange({var0},{var1},{var2},{var3}))
[condition][]it is not true that_virtualoccOfVPNIDnSVLANSTARTwithinsameUNIMAPPING{section} {errorcode}=(!(virtualoccOfVPNIDnSVLANSTARTwithinsameUNIMAPPING({section},{errorcode})))
[condition][]the {field} contains invalid values or with valid values {comma_separated_values} without spaces between them or repeated=((new Contains()).containsInvalidOrValidWithoutSpaceOrRepeated((xcb.xpath({field})).stringValue(),{comma_separated_values}))
[condition][]it is not true that_the pos {pos} to {pos} of segment {segnum} of the field {field} does not_equal_to_values {comma_separated_values}=(!((new LengthCheck()).posToPosOfSegmentNotEquals({pos},{pos},{segnum},(xcb.xpath({field})).stringValue(),{comma_separated_values})))
[condition][]it is not true that_any occurance of the {field1_with_xpath} is equal to {value}=(!((new Occurence()).anyOccurenceEqualToValue((xcb.xpath({field1_with_xpath})).stringValue(),{value})))
[condition][]it is not true that_the pon {PON} ccna {CCNA} and icsc{ICSC} combination has_the response with description {DESCRIPTION} and the previous version SUP1 has_order with status {CURRENTSTATUS} for the xml {xmlins}=(!(virtual_prevOrderSUP1CheckWithRespReject({PON},{CCNA},{ICSC},{DESCRIPTION},{CURRENTSTATUS},{xmlins})))
[condition][]the position_of Special Character is {pos} in {field}=((new DatatypeCheck()).checkPositionSP({pos},(xcb.xpath({field})).stringValue()))
[condition][]check previous versison servicetype for the pon {Pon_Field_Value} and version {Ver_Field_Value} and ccna {Ccna_Field_Value} and icsc {Icsc_Field_Value} with current rootnode value {Rootnode_Value}=((new SuplementOrderCheck()).checkServiceTypeInPreviousVersion({Pon_Field_Value},{Ver_Field_Value},{Ccna_Field_Value},{Icsc_Field_Value},{Rootnode_Value}))
[condition][]the value of {field} not equals the occurences of{section}=(virtualsaliValueOfFieldNotEqualsOccurenceOfOtherSection1((xcb.xpath({field})).stringValue(),{section}))
[condition][]the {field} from positions {pos1} to {pos2} is not populated or spaces=((new Populated()).rangeOfPositionIsNotPopulatedOrSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2}))
[condition][]any occurence of field{section}{field} is not populated and assosiated tag{tag} equals {values}and corresponding tag{tag} equals {values}=(virtualAnyOccurenceOfFieldNotPopulatedAndAssosiatedTagEqualsValuesAndCorrespondingTagEqualsValues({section},(xcb.xpath({field})).stringValue(),{tag},{values},{tag},{values}))
[condition][]the {section}{field} is not populated in all occurence=((new Occurence()).VirtualNoOccurenceIsPopulated({section},(xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the order with asog version  {ver} icsc  {icsc} and {msg_time_stamp} cannot be submitted because of ASOG Upgrade=(!(virtualAsogCutOverOrderReject({ver},{icsc},{msg_time_stamp})))
[condition][]the {field} has_the specified segment with number {segnum} whose length is in range {min} to {max} to support virgule or period as delimiter=((new LengthCheck()).virguleandPeriodSegmentNumberLengthInRange((xcb.xpath({field})).stringValue(),{segnum},{min},{max}))
[condition][]the {field} is Alpha with Special Characters=((new DatatypeCheck()).checkAlphaSP((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} has_the specified segment with number {segnum} whose length is in range {min} to {max} with leading spaces to support virgule or period as delimiter=(!((new LengthCheck()).virguleandPeriodSegmentRangeIsNumericWithLeadingSpaces((xcb.xpath({field})).stringValue(),{segnum},{min},{max})))
[condition][]it is not true that_virtualoccurenceofVACTandUACT2{section} {errorcode}=(!(virtualoccurenceofVACTandUACT2({section},{errorcode})))
[condition][]it is not true that_the {field_with_xpath} occurance is atmost {number_of_times}=(!((new Occurence()).atmostOccurenceOf((xcb.xpath({field_with_xpath})).stringValue(),{number_of_times})))
[condition][]it is not true that_the {field} has_the specified segment with number {segnum} whose length is in range {min} to {max} to support virgule or period as delimiter=(!((new LengthCheck()).virguleandPeriodSegmentNumberLengthInRange((xcb.xpath({field})).stringValue(),{segnum},{min},{max})))
[condition][]it is not true that_the {field} has_space as a special character=(!((new SpaceCheck()).spaceAsSpecialCharacter((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_any occurance of the {field1_with_xpath} is equal to comma seperated values{values}=(!((new Occurence()).anyOccurenceEqualToValues((xcb.xpath({field1_with_xpath})).stringValue(),{values})))
[condition][]it is not true that_all occurence of{section}{field} not equals{value} erroring to last occurence with{errorcode}=(!(virtualAllOccurenceOfFieldNotEqualsValue({section},(xcb.xpath({field})).stringValue(),{value},{errorcode})))
[condition][]the pos {pos} to {pos} of segment {segnum} of the field {field} does not_equal_to_values {comma_separated_values}=((new LengthCheck()).posToPosOfSegmentNotEquals({pos},{pos},{segnum},(xcb.xpath({field})).stringValue(),{comma_separated_values}))
[condition][]it is not true that_the multiple field {field} is not numeric in any occurence=(!((new Occurence()).dataTypeCheckForMultipleOccuringTag((xcb.xpath({field})).stringValue())))
[condition][]tagValueEqualsInPreviousVersion{var0} {var1} {var2} {var3} {var4} {var5} {var6}=((new SuplementOrderCheck()).tagValueEqualsInPreviousVersion({var0},{var1},{var2},{var3},{var4},{var5},{var6}))
[condition][]it is not true that_the {field} is not numeric with special character set{sp_characters}=(!((new DatatypeCheck()).notNumericWithAllSpSet((xcb.xpath({field})).stringValue(),{sp_characters})))
[condition][]it is not true that_virtualuactValueCheckWithPreviousVersion {section} {sup} {pon} {ver} {ccna} {icsc} {uact} {value} {uref} with {code}=(!((new Occurence()).VirtualUactValueCheckWithPreviousVersion({section},{sup},{pon},{ver},{ccna},{icsc},{uact},{value},{uref},{code})))
[condition][]it is not true that_noconfirmationOrderCheck pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=(!((new SuplementOrderCheck()).noConfirmationOrderCheck({pon},{ver},{ccna},{icsc},{description})))
[condition][]the {field} has {N} number of segments=((new LengthCheck()).fieldHasNumberOfSegments((xcb.xpath({field})).stringValue(),{N}))
[condition][]it is not true that_the {field} has_all lowercase characters=(!((new CapitalLetterCheck()).isAllLowerCase((xcb.xpath({field})).stringValue())))
[condition][]qtyCheckForCktact{var0} {var1} {var2}=((new Occurence()).qtyCheckForCktact({var0},{var1},{var2}))
[condition][]setNCILicense {var0}=((new SvcType()).setNCILicense({var0}))
[condition][]it is not true that_the_section{section} parent{parent} tag {tag} has_value{value} in any occurence=(!(virtualAnyOccurenceOfSaliTagEqualsValue({section},{parent},{tag},{value})))
[condition][]the {field_value} is present in NCI table=((new ASOGTABLE()).fetchAbbreviationNCITable((xcb.xpath({field_value})).stringValue()))
[condition][]tag value of the request order for the pon{pon}ver{ver}ccna{ccna}icsc{icsc}section{section}tag{tag} not equals {value}=((new SuplementOrderCheck()).requestDoesNothaveTheTagValue({pon},{ver},{ccna},{icsc},{section},{tag},{value}))
[condition][]the{section}{field} lengths not equals{value} with code {code}=(virtualResponseLengthCheck({section},(xcb.xpath({field})).stringValue(),{value},{code}))
[condition][]getRootXpath=((new Occurence()).getRootXpath())
[condition][]it is not true that_the {field} does not match with {compstring} having the specified Characters {numChar} from last within the comparison string=(!((new Position()).CompStringDoesntMatchWithSpecifiedChars((xcb.xpath({field})).stringValue(),{compstring},{numChar})))
[condition][]the CKTACT field check pon{pon}ver{ver}ccna{ccna}icsc{icsc} and xpath{xpath}tag{tag} with value{value} for rule{ruleErrorCode}=((new Occurence()).cktActCheck({pon},{ver},{ccna},{icsc},{xpath},{tag},{value},{ruleErrorCode}))
[condition][]firstPositionRangeGreaterThanSecondPositionRange{var0} {var1} {var2} {var3} {var4}=((new Position()).firstPositionRangeGreaterThanSecondPositionRange({var0},{var1},{var2},{var3},{var4}))
[condition][]routing matrix value check when first column is ALL{section}{subsect}{field}=(virtualRoutingMatrixCheck2({section},{subsect},(xcb.xpath({field})).stringValue()))
[condition][]it is not true that (!((new SuplementOrderCheck()).checkResponseTagExistInRequest()))=(!((new SuplementOrderCheck()).checkResponseTagExistInRequest()))
[condition][]the {pos1} to {pos2} of the {field} is present in LOCATION Table=((new ASOGTABLE()).posToPosfetchAbbreviationLOCATIONTable({pos1},{pos2},(xcb.xpath({field})).stringValue()))
[condition][]it is not true that_any occurence of the {field_with_xpath} is not populated in Response=(!((new Occurence()).anyOccurenceOfFieldNotPopulatedinResponse((xcb.xpath({field_with_xpath})).stringValue())))
[condition][]the {pos} position_of {field} field_is_equal_to_values {comma_seperated_values}=((new Position()).positionOftagValueEqualToValues({pos},(xcb.xpath({field})).stringValue(),{comma_seperated_values}))
[condition][]it is not true that_the field {field} is not numeric from postion {posn1} to position {posn2}=(!((new Contains()).positionalNotNumeric((xcb.xpath({field})).stringValue(),{posn1},{posn2})))
[condition][]it is not true that_alloccuranceof field{path} not equals values{comma_seperated_values}=(!((new Occurence()).allOccurenceOfFieldNotEqualsValues({path},{comma_seperated_values})))
[condition][]it is not true that_the sup {Sup_Field_Value} is populated with pon {Pon_Field_Value} and version {Ver_Field_Value} and ccna {Ccna_Field_Value} and icsc {Icsc_Field_Value} on the current order and matching with the previous order which has_a status CANCEL=(!((new SuplementOrderCheck()).supFieldCheck({Sup_Field_Value},{Pon_Field_Value},{Ver_Field_Value},{Ccna_Field_Value},{Icsc_Field_Value})))
[condition][]it is not true that_the sup {Sup_Field_Value} is populated with pon {Pon_Field_Value} and version {Ver_Field_Value} and ccna {Ccna_Field_Value} and icsc {Icsc_Field_Value} and qty {Qty_Field_Value} on the current order which has_decreasing QTY with respect to the previous order=(!((new SuplementOrderCheck()).qtyFieldCheck({Sup_Field_Value},{Pon_Field_Value},{Ver_Field_Value},{Ccna_Field_Value},{Icsc_Field_Value},{Qty_Field_Value})))
[condition][]it is not true that_the {field} has_alpha characters in the specified range {start} to {end}=(!((new RangeOfValues()).numberOfAlphaInSpecRange((xcb.xpath({field})).stringValue(),{start},{end})))
[condition][]any segment of the {field_value} delimeted by space does not equal {comma_separated_values}=((new LengthCheck()).segmentsNotEquals((xcb.xpath({field_value})).stringValue(),{comma_separated_values}))
[condition][]the {field} does not contain {CommaSeparatedValues}=((new Contains()).doesNotContains((xcb.xpath({field})).stringValue(),{CommaSeparatedValues}))
[condition][]the {field} has_ampersand which is not preceeded and followed by space=((new SpaceCheck()).isAmpersandNotPrecFollSpace((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} has_none valid values {comma_seperated_values}=(!((new isValidValue()).isNoneValidValues((xcb.xpath({field})).stringValue(),{comma_seperated_values})))
[condition][]the value of {field} not equals the occurences of{section}{subsectn}=(virtualsaliValueOfFieldNotEqualsOccurenceOfOtherSection((xcb.xpath({field})).stringValue(),{section},{subsectn}))
[condition][]it is not true that_anyARIPrilocAndPrilocSpotCheck{var0} {var1} {var2}=(!((new Occurence()).anyARIPrilocAndPrilocSpotCheck({var0},{var1},{var2})))
[condition][]the each position_from {pos1} to {pos2} of {field} is not_equal_to_values{comma_seperated_values}=((new Position()).checkEachPositionsInRangeNotEqualToValues({pos1},{pos2},(xcb.xpath({field})).stringValue(),{comma_seperated_values}))
[condition][]it is not true that_virguleandPeriodSegmentValueEqualToValues{var0} {var1} {var2}=(!((new Equals()).virguleandPeriodSegmentValueEqualToValues({var0},{var1},{var2})))
[condition][]((new SuplementOrderCheck()).checkResponseTagExistInRequest())=((new SuplementOrderCheck()).checkResponseTagExistInRequest())
[condition][]it is not true that_the {field} has_an abbreviation name=(!((new ThoroughFareHelper()).fetchAbbreviationName((xcb.xpath({field})).stringValue())))
[condition][]the {pos} position_Of {field1} equal to {pos} position_Of {field2}=((new Contains()).positionOfFieldEqualToPositionOfField({pos},(xcb.xpath({field1})).stringValue(),{pos},(xcb.xpath({field2})).stringValue()))
[condition][]it is not true that_the {field} has_from the start position {pos} to end position {pos} the constant {constant} followed by a Dot and followed by {number} alphanumeric characters=(!((new DatatypeCheck()).constantFollowedByDotFollowedByAlphaNumeric((xcb.xpath({field})).stringValue(),{pos},{pos},{constant},{number})))
[condition][]the {field_date1} is todays date=((new DateCheck()).isToday((xcb.xpath({field_date1})).stringValue()))
[condition][]virtualALCONfieldPopulated{priloc} {secloc} {errorcode}=(virtualALCONfieldPopulated({priloc},{secloc},{errorcode}))
[condition][]it is not true that_the {field} has_date format as {format}=(!((new DateFormatCheck()).dateCheck((xcb.xpath({field})).stringValue(),{format})))
[condition][]it is not true that_fieldPositionInRange{var0} {var1} {var2} {var3}=(!((new RangeOfValues()).fieldPositionInRange({var0},{var1},{var2},{var3})))
[condition][]The number of occurence of {path} populated is greater than {number}=((new Occurence()).NumberOfoccurencepopulatedisgreaterthan({path},{number}))
[condition][]the {field_date1} is a working day=((new DateCheck()).isWorkingDay((xcb.xpath({field_date1})).stringValue()))
[condition][]it is not true that_the {field} has_both uppercase and lowercase characters=(!((new CapitalLetterCheck()).isUpperAndLowerCase((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} position {pos} and {pos} is greater than or equal to {pos} and {pos}=(!((new Contains()).checkPositionalValuesGreaterThanOrEqualTo((xcb.xpath({field})).stringValue(),{pos},{pos},{pos},{pos})))
[condition][]it is not true that_noOfOccurence{var0}=(!((new Occurence()).noOfOccurence({var0})))
[condition][]vitualsvlanthirdOccurenceProhibit{vector} {errorcode}=((new Occurence()).vitualsvlanthirdOccurenceProhibit({vector},{errorcode}))
[condition][]the {pos} and {pos} of {field} is_equal_to_values {CommaSeparatedValues}=((new Position()).twoPositionValueofTagEqualToValues({pos},{pos},(xcb.xpath({field})).stringValue(),{CommaSeparatedValues}))
[condition][]the {field} contains roman numerals=((new Contains()).containsRoman((xcb.xpath({field})).stringValue()))
[condition][]the {field} has_not a valid values {comma_seperated_values}=((new isValidValue()).isNotValidValues((xcb.xpath({field})).stringValue(),{comma_seperated_values}))
[condition][]virtualIntegerToString{var0}=(virtualIntegerToString({var0}))
[condition][]the {field} has_no values{comma_seperated_values} in the segment{segnum} to support virgule or period as delimiter=((new Equals()).virguleandPeriodSegmentValueNotEqualToValues((xcb.xpath({field})).stringValue(),{comma_seperated_values},{segnum}))
[condition][]checkCapsInField2ForPosInField1{var0} {var1} {var2}=((new CapitalLetterCheck()).checkCapsInField2ForPosInField1({var0},{var1},{var2}))
[condition][]it is not true that_the {section} for lref when uact is not equal to CKT with {errorcode}=(!(virtuallrefProhibitedWhenUactNotEqualsCNK({section},{errorcode})))
[condition][]it is not true that_from the {pos1} to {pos2} has {format} for the {field}=(!((new DateFormatCheck()).time_format_chk({pos1},{pos2},{format},(xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} is compared with the specified positions {pos1} to {pos2} with values {value1} or {value2}=(!((new Position()).compareCharAtAnyPositionWithAnyValue((xcb.xpath({field})).stringValue(),{pos1},{pos2},{value1},{value2})))
[condition][]it is not true that_the {field} contains roman numerals=(!((new Contains()).containsRoman((xcb.xpath({field})).stringValue())))
[condition][]the {field} has_segment with specified {segnum} of the specified {length}=((new LengthCheck()).segmentNumberLengthEqualTo((xcb.xpath({field})).stringValue(),{segnum},{length}))
[condition][]the {field} has_consecutive uppercase characters and should not be followed by space=((new CapitalLetterCheck()).consecUpperCaseWithNoSpaceAfter((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the sup {Sup_Field_Value} is populated with pon {Pon_Field_Value} and version {Ver_Field_Value} and ccna {Ccna_Field_Value} and icsc {Icsc_Field_Value} and the UNIMAPPING section which had the field {Field_Name} of values {comma_separated_values} and with all its elements of the previous order is not equal to none of the UNIMAPPING section with all its elements in current order=(!((new SuplementOrderCheck()).checkActiveUrefDoesNotExists({Sup_Field_Value},{Pon_Field_Value},{Ver_Field_Value},{Ccna_Field_Value},{Icsc_Field_Value},{Field_Name},{comma_separated_values})))
[condition][]the {field} with segment{segnum} is populated=((new DatatypeCheck()).segmentPopulated((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]the message type for the valid interface equals {values}=((new SuplementOrderCheck()).checkMessageType({values}))
[condition][]it is not true that_ccnaMultiEcIcscCheck{var0} {var1} {var2}=(!((new SuplementOrderCheck()).ccnaMultiEcIcscCheck({var0},{var1},{var2})))
[condition][]it is not true that_the maximum length of {field} is {value}=(!((new LengthCheck()).checkMaximumlength((xcb.xpath({field})).stringValue(),{value})))
[condition][]the {field} from {pos1} to {pos2} of the segment{segnum} are not alpha characters to supportvirgule or period as delimiter=((new LengthCheck()).virguleandPeriodPosToPosOfSegmentAreNotAlpha((xcb.xpath({field})).stringValue(),{pos1},{pos2},{segnum}))
[condition][]it is not true that_for the Trading Partner with the ICSC {icsc_value} the {date_value} falls on holiday=(!((new HOLIDAY()).fetchTPHoliday({icsc_value},{date_value})))
[condition][]the {field} from positions {pos1} to {pos2} is populated or not spaces=((new Populated()).rangeOfPositionIsPopulatedOrNotSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2}))
[condition][]it is not true that_virguleFollowedByVirgule{var0}=(!((new Contains()).virguleFollowedByVirgule({var0})))
[condition][]it is not true that_the {pos} position_Of {field1} equal to {pos} position_Of {field2}=(!((new Contains()).positionOfFieldEqualToPositionOfField({pos},(xcb.xpath({field1})).stringValue(),{pos},(xcb.xpath({field2})).stringValue())))
[condition][]the {field} has_last character as upper which is followed by lower case character=((new CapitalLetterCheck()).lastCharUpperFollLower((xcb.xpath({field})).stringValue()))
[condition][]presenceOfSpaceOtherThanSpecifiedPosition{var0} {var1}=((new Position()).presenceOfSpaceOtherThanSpecifiedPosition({var0},{var1}))
[condition][]it is not true that_the pon{field} ver{field} section{section} tag{tag} is populated in Request against Response=(!((new SuplementOrderCheck()).checkResponseTagExistInRequest((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{section},{tag})))
[condition][]segmentValueEqualToValues{var0} {var1} {var2}=((new Equals()).segmentValueEqualToValues({var0},{var1},{var2}))
[condition][]the {pos} position_of {field1} is equal to {pos} position_of {field2}=((new Position()).positionOfOneFieldIsEqualToPositionOfAnother({pos},(xcb.xpath({field1})).stringValue(),{pos},(xcb.xpath({field2})).stringValue()))
[condition][]the field {field_1} is greater than field {field_2}=((new Equals()).field1IsGreaterThanField2((xcb.xpath({field_1})).stringValue(),(xcb.xpath({field_2})).stringValue()))
[condition][]it is not true that_the {field} is Alpha with Special Characters=(!((new DatatypeCheck()).checkAlphaSP((xcb.xpath({field})).stringValue())))
[condition][]the difference between {field_date1} and {field_date2} is not equal to one year=((new DateCheck()).isRangeNotEqualToOneYear((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue()))
[condition][]it is not true that_the_section {section} for the field {feild} with {compvalue} and {innercompvalue} for field {innerfeild} and {errorcode}=(!(virtualoccurenceofSvlanMapping({section},{feild},{compvalue},{innercompvalue},{innerfeild},{errorcode})))
[condition][]it is not true that_the position {pos1} and {pos2} of {field} is between {start_range} and {end_range}=(!((new RangeOfValues()).twoFieldPositionInRange({pos1},{pos2},(xcb.xpath({field})).stringValue(),{start_range},{end_range})))
[condition][]it is not true that_the {field} has_specified segment {segnum} which contains alpha numeric characters with virgule or period as delimiter=(!((new DatatypeCheck()).virguleandPeriodSegmentEqualToAlphaNumeric((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]it is not true that_the difference between {field_date1} and {field_date2} is equal to one year=(!((new DateCheck()).isRangeEqualToOneYear((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue())))
[condition][]it is not true that_the {field} has_segment with specified {segnum} of the specified {length} to support virgule or period=(!((new LengthCheck()).virguleandPeriodSegmentNumberLengthEqualTo((xcb.xpath({field})).stringValue(),{segnum},{length})))
[condition][]it is not true that_the difference for the given {CCNA} {NC} and {ICSC} between the {ASR_DDD} and the current date  is less than  the Interval Duration from the table=(!((new IntervalDurationMatcher()).isIntervalDurationMatching({CCNA},{NC},{ICSC},{ASR_DDD})))
[condition][]segmentRangeIsNumericWithLeadingSpaces{var0} {var1} {var2} {var3}=((new LengthCheck()).segmentRangeIsNumericWithLeadingSpaces({var0},{var1},{var2},{var3}))
[condition][]it is not true that_the {field} does not match with {field2} at the specified character positions {pos1} to {pos2}=(!((new Position()).compStringDoesntMatchTagValueAtSpecPosition((xcb.xpath({field})).stringValue(),(xcb.xpath({field2})).stringValue(),{pos1},{pos2})))
[condition][]it is not true that_positionOfAnyFieldNotEqualToCharacter{var0} {var1} {var2}=(!((new Occurence()).positionOfAnyFieldNotEqualToCharacter({var0},{var1},{var2})))
[condition][]it is not true that_the icsc {field_value} has_the license for the table {NC_NCI_ICSC_CLLI}=(!((new ASOGTABLE()).checkIcscLicenseForTable((xcb.xpath({field_value})).stringValue(),{NC_NCI_ICSC_CLLI})))
[condition][]valueOfFieldIsEqualToccurenceOfAnotherField{var0} {var1}=((new Occurence()).valueOfFieldIsEqualToccurenceOfAnotherField({var0},{var1}))
[condition][]it is not true that (!((new ReqTypeAct()).getActivity()))=(!((new ReqTypeAct()).getActivity()))
[condition][]the {field} is not equal to specified val {val}=((new Equals()).fieldnoteqval((xcb.xpath({field})).stringValue(),{val}))
[condition][]it is not true that_Is the {field_Date1} less than {comparison_Date} in the format {CCYYMMDD}=(!((new DateFormatCheck()).isFieldDateLessThanComparisonDateInspecifiedFormat((xcb.xpath({field_Date1})).stringValue(),{comparison_Date},{CCYYMMDD})))
[condition][]the {field} equals {value}=((new Equals()).isEquals((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the value of{field} is not equal to occurence of the {field_with_xpath}=(!((new Occurence()).valueOfFieldIsNotEqualToccurenceOfAnotherField((xcb.xpath({field})).stringValue(),(xcb.xpath({field_with_xpath})).stringValue())))
[condition][]it is not true that_the {field} has_all uppercase characters for comma seperated values=(!((new CapitalLetterCheck()).isAllUpperCaseForCSV((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_setICSCLicense {var0}=(!((new SvcType()).setICSCLicense({var0})))
[condition][]it is not true that_virtualoccurenceofVACTandUACT {section} {errorcode}=(!(virtualoccurenceofVACTandUACT({section},{errorcode})))
[condition][]the {field} contains {CommaSeparatedValues}=((new Contains()).contains((xcb.xpath({field})).stringValue(),{CommaSeparatedValues}))
[condition][]the {field} has_date format check1 {format1}=((new DateFormatCheck()).dateCheck1((xcb.xpath({field})).stringValue(),{format1}))
[condition][]it is not true that_the {field_date1} is a Weekend=(!((new DateCheck()).isHoliday((xcb.xpath({field_date1})).stringValue())))
[condition][]the pon{field} ver{field} section{section} tag{tag} at {pos} is populated in Request against Response=((new SuplementOrderCheck()).checkResponseTagExistInRequestatPosition((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{section},{tag},{pos}))
[condition][]it is not true that_the ASR Request order exists for the pon {PON}ccna {CCNA} and icsc {ICSC}=(!((new SuplementOrderCheck()).checkRequestPonExistsInDatabase({PON},{CCNA},{ICSC})))
[condition][]it is not true that_the {field} is Numeric=(!((new DatatypeCheck()).checkNumeric((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the value of {field1_with_xpath} is equal to number of occurance of {field2_with_xpath}=(!((new Occurence()).tagValueOfOneFieldEqualToNoOfOccurenceOfAnotherField((xcb.xpath({field1_with_xpath})).stringValue(),(xcb.xpath({field2_with_xpath})).stringValue())))
[condition][]the {field} is Numeric with Special Characters Set {set_of_special_characters}=((new DatatypeCheck()).checkNumericSPSet((xcb.xpath({field})).stringValue(),{set_of_special_characters}))
[condition][]it is not true that_{field} has_atleast {occurance} occurances populated=(!((new Occurence()).atleastOccurenceOfTagPopulated((xcb.xpath({field})).stringValue(),{occurance})))
[condition][]the {field} is equal or greater than {value}=((new Equals()).isEqualOrGreaterThan((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the {pos} and {pos} of {field} is not_equal_to_values {CommaSeparatedValues}=(!((new Position()).twoPositionValueofTagNotEqualToValues({pos},{pos},(xcb.xpath({field})).stringValue(),{CommaSeparatedValues})))
[condition][]virtualoccurenceofVACTandUACT3{section} {errorcode}=(virtualoccurenceofVACTandUACT3({section},{errorcode}))
[condition][]it is not true that_the {field} is in the range A1 to Z99=(!((new RangeOfValues()).rangeCheckA1_Z99((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_any segment of the {field_value} delimeted by space does not equal {comma_separated_values}=(!((new LengthCheck()).segmentsNotEquals((xcb.xpath({field_value})).stringValue(),{comma_separated_values})))
[condition][]it is not true that_the pon {PON} ccna {CCNA}  icsc{ICSC} and ver{ver} combination has_the response with description {DESCRIPTION} and the previous version SUP1 order with status {CURRENTSTATUS} for the xml {xmlins}=(!(virtual_prevOrderSUP1CheckWithRespAccept({PON},{CCNA},{ICSC},{ver},{DESCRIPTION},{CURRENTSTATUS},{xmlins})))
[condition][]it is not true that_the {field} has_specified segment {segnum} which contains alpha numeric characters=(!((new DatatypeCheck()).segmentEqualToAlphaNumeric((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]timeFormatWithRange{var0} {var1} {var2}=((new TimeFormatCheck()).timeFormatWithRange({var0},{var1},{var2}))
[condition][]any occurance of the {field1_with_xpath} is equal to {value}=((new Occurence()).anyOccurenceEqualToValue((xcb.xpath({field1_with_xpath})).stringValue(),{value}))
[condition][]the segment {segnum} length of the field {field_value} is in the range {min} and {max}=(virtualSegmentNumberLengthInRange({segnum},(xcb.xpath({field_value})).stringValue(),{min},{max}))
[condition][]the {field_date1} is equal to {field_date2}=((new DateCheck()).isEqualTo((xcb.xpath({field_date1})).stringValue(),(xcb.xpath({field_date2})).stringValue()))
[condition][]it is not true that_checkForLowerCaseLettersAfterNumbers{var0}=(!((new CapitalLetterCheck()).checkForLowerCaseLettersAfterNumbers({var0})))
[condition][]virtualoccOfVPNIDnSVLANSTARTwithinsameUNIMAPPING{section} {errorcode}=(virtualoccOfVPNIDnSVLANSTARTwithinsameUNIMAPPING({section},{errorcode}))
[condition][]it is not true that_the field {field} with segment {segnum} is populated=(!((new Populated()).segmentIsPopulated((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]it is not true that_the {fieldName} in {parentSection} is less than {fieldValue} for the {pon} {ver} {ccna} {icsc}=(!((new SuplementOrderCheck()).isCurrentDDDLessThanPreviousVersionDDD((xcb.xpath({fieldName})).stringValue(),{parentSection},(xcb.xpath({fieldValue})).stringValue(),{pon},{ver},{ccna},{icsc})))
[condition][]it is not true that_confirmationOrderCheckDes pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=(!((new SuplementOrderCheck()).confirmationOrderCheckDes({pon},{ver},{ccna},{icsc},{description})))
[condition][]the pos1{pos1} to pos2{pos2} of the field{field_value} not in range {start_value} to {end_value}=((new RangeOfValues()).checkPos1ToPos2ValueNotInRange({pos1},{pos2},(xcb.xpath({field_value})).stringValue(),{start_value},{end_value}))
[condition][]it is not true that_the {field} is Alpha=(!((new DatatypeCheck()).checkAlpha((xcb.xpath({field})).stringValue())))
[condition][]the last character Of {field} is {value}=((new Equals()).lastCharacterOfField((xcb.xpath({field})).stringValue(),{value}))
[condition][]the_length_of {field} is equal to {value}=((new LengthCheck()).checkLength((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the {field} is less than {value}=(!((new Equals()).isLessThan((xcb.xpath({field})).stringValue(),{value})))
[condition][]the {field_with_xpath} occurance is atmost {number_of_times}=((new Occurence()).atmostOccurenceOf((xcb.xpath({field_with_xpath})).stringValue(),{number_of_times}))
[condition][]it is not true that_the {field} equals {value}=(!((new Equals()).isEquals((xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_any occurance of the {field1_with_xpath} is not equal to {value}=(!((new Occurence()).anyOccurenceNotEqualToValue((xcb.xpath({field1_with_xpath})).stringValue(),{value})))
[condition][]it is not true that_the version is {VER} not equal to the latest database version for the pon {PON} ccna {CCNA} and icsc{ICSC} with the status {STATUS}=(!((new SuplementOrderCheck()).verNotEqualToLatestDBVersion({VER},{PON},{CCNA},{ICSC},{STATUS})))
[condition][]it is not true that_the {field} from positions {pos1} to {pos2} is populated or spaces=(!((new Populated()).rangeOfPositionIsPopulatedOrSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2})))
[condition][]it is not true that_the_section{section} parent{parent} tag {tag} does not have value{value} in any occurence=(!(virtualNoneOccurenceEqualsValue({section},{parent},{tag},{value})))
[condition][]checkResponseIcscTagExistInRequestIcsc{var0} {var1} {var2} {var3}=((new SuplementOrderCheck()).checkResponse_IcscTagExistInRequestIcsc({var0},{var1},{var2},{var3}))
[condition][]it is not true that_the {field} contains {num} of consecutive uppercase Alpha Characters=(!((new CapitalLetterCheck()).containsConsecutiveUppercaseAlphaCharacters((xcb.xpath({field})).stringValue(),{num})))
[condition][]the {field} position {pos} and {pos} is greater than or equal to {pos} and {pos}=((new Contains()).checkPositionalValuesGreaterThanOrEqualTo((xcb.xpath({field})).stringValue(),{pos},{pos},{pos},{pos}))
[condition][]it is not true that_Check for reqtyp{field} pon{field}ver{ver}ccna{ccna}icsc{icsc}=(!((new SuplementOrderCheck()).reqtypFieldCheck((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{ver},{ccna},{icsc})))
[condition][]it is not true that_characterFollowedBySpace{var0} {var1}=(!((new Contains()).characterFollowedBySpace({var0},{var1})))
[condition][]it is not true that_the {field} is in the range ZL1 to ZL8=(!((new RangeOfValues()).rangeCheckZl1_Zl8((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_no of occurences of tag {field_xpath1} with {field1} and {field_xpath2} with {field2} are equal=(!((new Occurence()).noOfOccurencesOfBothTagAreEqualForSpecifiedPairValue((xcb.xpath({field_xpath1})).stringValue(),(xcb.xpath({field1})).stringValue(),(xcb.xpath({field_xpath2})).stringValue(),(xcb.xpath({field2})).stringValue())))
[condition][]the field differs from previous version tag value for the pon {PON} version {VER}icsc{ICSC} and ccna{CCNA} {field_name} of {parent_name} at pos{POS} with field {field_value}=((new SuplementOrderCheck()).tagValueDiffersInPreviousVersionatspecpos({PON},{VER},{ICSC},{CCNA},(xcb.xpath({field_name})).stringValue(),{parent_name},{POS},(xcb.xpath({field_value})).stringValue()))
[condition][]it is not true that_the position_of Numeric is {pos} in {field}=(!((new DatatypeCheck()).checkPositionNumeric({pos},(xcb.xpath({field})).stringValue())))
[condition][]the {field} doesnot have {N} number of segments=((new LengthCheck()).fieldDoesNothaveNumberOfSegments((xcb.xpath({field})).stringValue(),{N}))
[condition][]the {field} is compared with its position {pos1} to {pos2} with values {values}=((new Position()).compareCharAtAnyPositionWithAnyNumberOfValue((xcb.xpath({field})).stringValue(),{pos1},{pos2},{values}))
[condition][]it is not true that_the segment {segnum} length of field {field_value} is in the range {min} and {max}=(!((new LengthCheck()).segmentNumberLengthInRange({segnum},(xcb.xpath({field_value})).stringValue(),{min},{max})))
[condition][]noconfirmationOrderCheckNew pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}dedicaterecievecustomer{drc}=((new SuplementOrderCheck()).noConfirmationOrderCheckNew({pon},{ver},{ccna},{icsc},{description},{drc}))
[condition][]it is not true that_tagValueEqualsInPreviousVersion{var0} {var1} {var2} {var3} {var4} {var5} {var6}=(!((new SuplementOrderCheck()).tagValueEqualsInPreviousVersion({var0},{var1},{var2},{var3},{var4},{var5},{var6})))
[condition][]it is not true that_the {field} is not equal to specified val {val}=(!((new Equals()).fieldnoteqval((xcb.xpath({field})).stringValue(),{val})))
[condition][]set the request type of to {var0}=((new ReqTypeAct()).setRequestType({var0}))
[condition][]the field {field_name} with parent section {parent_name} is populated in previous version for the pon {PON} ver {VER} ccna {CCNA} and icsc {ICSC}=((new SuplementOrderCheck()).fieldPopulatedInPreviousVersion((xcb.xpath({field_name})).stringValue(),{parent_name},{PON},{VER},{CCNA},{ICSC}))
[condition][]it is not true that_getRootXpath=(!((new Occurence()).getRootXpath()))
[condition][]it is not true that_the field {field_name} of {parent_name} with value {field_value} differs from previous version tag value for the pon {PON} version {VER} ccna {CCNA} and icsc{ICSC} and compare with {val1}{val2}=(!((new SuplementOrderCheck()).CHKVAR_Access((xcb.xpath({field_name})).stringValue(),{parent_name},(xcb.xpath({field_value})).stringValue(),{PON},{VER},{CCNA},{ICSC},{val1},{val2})))
[consequence][]the error code {field1} the error message {field2} for the field {field3}=(xcb.logError({field1},{field2},{field3}))
[condition][]the {section} {field} is not unique in all the occurences with errorCode {errorcode} and errorMessage {errormessage}=FieldShouldNotUnique(xcb,{section},{field},{errorcode},{errormessage})
[condition][]xcb object=xcb : XOMContainerBean()
[condition][]Evaluate=eval
[condition][]Start Brace=(
[condition][]End Brace=)
[condition][]AND=&&
[condition][]OR=||
